{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"_n",
				"_numChannels"
			],
			[
				"Ele",
				"ElectrodeWithoutStim"
			],
			[
				"probe",
				"probeMenu"
			],
			[
				"CMAKE_CURR",
				"CMAKE_CURRENT_SOURCE_DIR\tbuiltin"
			],
			[
				"position",
				"positionProba"
			],
			[
				"get",
				"get_operations"
			],
			[
				"feedDat",
				"feedDictDataBin"
			],
			[
				"data",
				"dataSelection"
			],
			[
				"chann",
				"channelList"
			],
			[
				"filter",
				"filter_one_sample"
			],
			[
				"previous",
				"previousChannels"
			],
			[
				"filtered",
				"filteredSignal"
			],
			[
				"xml",
				"xml_path"
			],
			[
				"rw",
				"rawSpikes"
			],
			[
				"Stand",
				"StanddevCNN"
			],
			[
				"Error",
				"ErrorCNN"
			],
			[
				"scatt",
				"scattWithError"
			],
			[
				"fig",
				"figsize"
			],
			[
				"selec",
				"selectionTrue"
			],
			[
				"selection",
				"selectionCNN"
			],
			[
				"select",
				"selectionLSTM"
			],
			[
				"max",
				"maxPos"
			],
			[
				"tetr",
				"tetrode"
			],
			[
				"tetro",
				"tetrode2"
			],
			[
				"tetrode",
				"tetrode2"
			],
			[
				"feedD",
				"feedDictDataBin"
			],
			[
				"bin_st",
				"bin_stop_time"
			],
			[
				"bin_sta",
				"bin_start_time"
			],
			[
				"bin",
				"bin_time"
			],
			[
				"testing",
				"testingTensors"
			],
			[
				"masP",
				"maxPos"
			],
			[
				"subplot",
				"subplot2grid"
			],
			[
				"X_tr",
				"X_True"
			],
			[
				"Err",
				"ErrorLSTM"
			],
			[
				"test",
				"testOutput"
			],
			[
				"Y_",
				"Y_true"
			],
			[
				"b",
				"b"
			],
			[
				"open",
				"openEphysFilter"
			],
			[
				"traing",
				"trainingTimeSelection"
			],
			[
				"training",
				"trainingTimeSelection"
			],
			[
				"nClus",
				"nClusters-1"
			],
			[
				"spik",
				"spikeCursor"
			],
			[
				"label",
				"labelCursor"
			],
			[
				"res",
				"res_str"
			],
			[
				"sele",
				"selectGroupInDict"
			],
			[
				"speed",
				"speed_cut"
			],
			[
				"i",
				"i"
			],
			[
				"list",
				"list_channels"
			],
			[
				"spikes_",
				"spikes_time"
			],
			[
				"sleepStat",
				"sleepStateFromText"
			],
			[
				"sleep",
				"sleepStateSelection"
			],
			[
				"Sleep",
				"SleepScorerProcessor"
			],
			[
				"SleepSco",
				"SleepScorerProcessor"
			],
			[
				"eventCh",
				"eventChannelName"
			],
			[
				"setS",
				"setSelectedItemIndex"
			],
			[
				"ttlChann",
				"ttlChannelSourceID"
			],
			[
				"eventI",
				"eventId"
			],
			[
				"e",
				"eventInfo"
			],
			[
				"TTLEve",
				"TTLEventPtr"
			],
			[
				"Event",
				"EventChannel"
			],
			[
				"Stimulator",
				"StimulatorProcessor"
			],
			[
				"Stimula",
				"StimulatorProcessor"
			],
			[
				"curr",
				"currentSpikeIndex"
			],
			[
				"channle",
				"channels"
			],
			[
				"elec",
				"electrodeNum"
			],
			[
				"nS",
				"nSpikesInWindow"
			],
			[
				"Stim",
				"StimulatorProcessor"
			],
			[
				"stimul",
				"stimulationPin"
			],
			[
				"gamma",
				"gammaProcessor"
			],
			[
				"chip",
				"chipChannel"
			],
			[
				"board",
				"boardStream"
			],
			[
				"MOBSc",
				"MOBSchannelIndices"
			],
			[
				"highpass",
				"highpassFilterStream"
			],
			[
				"highpassF",
				"highpassFilterStream"
			],
			[
				"str",
				"stream"
			],
			[
				"numD",
				"numDataStreams"
			],
			[
				"spike",
				"spikeIndices"
			],
			[
				"stimI",
				"stimIndices"
			],
			[
				"spikeI",
				"spikeIt"
			],
			[
				"spi",
				"spikeIt"
			],
			[
				"mouse",
				"mouseId"
			],
			[
				"triggerBoxe",
				"triggerBoxesEnabled"
			],
			[
				"trigerBox",
				"triggerBoxesTypes"
			],
			[
				"triggerBox",
				"triggerBoxesPositions"
			],
			[
				"triggerBoxes",
				"triggerBoxesSizes"
			],
			[
				"first",
				"firstBoxes"
			],
			[
				"addTrigg",
				"addTriggerBoxButton"
			],
			[
				"add",
				"addExclusionTriggerBoxButton"
			],
			[
				"boxes",
				"boxesTypes"
			],
			[
				"triggerBoex",
				"triggerBoxesTypes"
			],
			[
				"trigger",
				"triggerBoxesTypes"
			],
			[
				"firstBoxes",
				"firstBoxesTypes"
			],
			[
				"firstBoxe",
				"firstBoxesTypes"
			],
			[
				"array",
				"arraySize"
			],
			[
				"ara",
				"arraySize"
			],
			[
				"thres",
				"thresholdStream"
			],
			[
				"true",
				"truePos"
			],
			[
				"json",
				"jsonPath"
			],
			[
				"infoF",
				"infoFileName"
			],
			[
				"previou",
				"previousInfoFile"
			],
			[
				"base",
				"baseName"
			],
			[
				"files",
				"filesAndFolders"
			],
			[
				"amplifier",
				"amplifierStream"
			],
			[
				"stimulator",
				"stimulatorStream"
			],
			[
				"amplifi",
				"amplifierFile"
			],
			[
				"spikeW",
				"spikeWaveform"
			],
			[
				"scope",
				"scopeColors"
			],
			[
				"changeFilt",
				"changeFilterChannel"
			],
			[
				"highpassFilter",
				"highpassFilterMode"
			],
			[
				"setHigh",
				"setHighpassFilterMode"
			],
			[
				"highPassFilterL",
				"highpassFilterLineEdit"
			],
			[
				"highpassFil",
				"highpassFilterComboBoxMode"
			],
			[
				"highPass",
				"highpassFilterComboBoxMode"
			],
			[
				"synth",
				"synthMode"
			],
			[
				"sendS",
				"sendStimButton"
			],
			[
				"Signal",
				"SignalProcessor"
			],
			[
				"fake",
				"fakeTrigger"
			],
			[
				"record",
				"recordTriggerPolarity"
			],
			[
				"recor",
				"recordTriggerPolarity"
			],
			[
				"stim",
				"stimulatorStream"
			],
			[
				"buffer",
				"bufferIndex"
			],
			[
				"ignore",
				"ignoreNext"
			],
			[
				"num",
				"numMice"
			],
			[
				"ignor",
				"ignoreNext"
			],
			[
				"igno",
				"ignoreNext"
			],
			[
				"sleepS",
				"sleepScoringEnabled"
			],
			[
				"numO",
				"numUsbBlocksToRead"
			],
			[
				"signal",
				"signalProcessor"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "/*\n------------------------------------------------------------------\n\nThis file is part of the Open Ephys GUI\nCopyright (C) 2013 Open Ephys\n\n------------------------------------------------------------------\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n#include <stdio.h>\n#include <algorithm>\n#include \"SpikeSortBoxesWithStim.h\"\n#include \"SpikeSorterWithStim.h\"\n\nPointDWithStim::PointDWithStim()\n{\n    X = Y = 0;\n}\n\n\nPointDWithStim::PointDWithStim(float x, float y)\n{\n    X = x;\n    Y = y;\n}\n\nPointDWithStim::PointDWithStim(const PointDWithStim& P)\n{\n    X = P.X;\n    Y = P.Y;\n}\n\nPointDWithStim& PointDWithStim::operator+=(const PointDWithStim& rhs)\n{\n    X += rhs.X;\n    Y += rhs.Y;\n    return *this;\n}\n\nPointDWithStim& PointDWithStim::operator-=(const PointDWithStim& rhs)\n{\n    X -= rhs.X;\n    Y -= rhs.Y;\n    return *this;\n}\n\nconst PointDWithStim PointDWithStim::operator+(const PointDWithStim& other) const\n{\n    PointDWithStim result = *this;\n    result += other;\n    return result;\n}\n\n\nconst PointDWithStim PointDWithStim::operator-(const PointDWithStim& other) const\n{\n    PointDWithStim result = *this;\n    result -= other;\n    return result;\n}\n\n\nconst PointDWithStim PointDWithStim::operator*(const PointDWithStim& other) const\n{\n    PointDWithStim result = *this;\n    result.X *= other.X;\n    result.Y *= other.Y;\n    return result;\n\n}\n\nfloat PointDWithStim::cross(PointDWithStim c) const\n{\n    return X*c.Y-Y*c.X;\n}\n\n/**************************************/\n\n\nBoxWithStim::BoxWithStim()\n{\n    x = -0.2; // in ms\n    y = -10; // in uV\n    w = 0.5; // in ms\n    h = 70; // in uV\n    channel=0;\n}\n\n\nBoxWithStim::BoxWithStim(int ch)\n{\n    x = -0.2; // in ms\n    y = -10; // in uV\n    w = 0.5; // in ms\n    h = 70; // in uV\n    channel = ch;\n}\n\nBoxWithStim::BoxWithStim(float X, float Y, float W, float H, int ch)\n{\n    x = X;\n    y = Y;\n    w = W;\n    h = H;\n    channel = ch;\n}\n\nbool BoxWithStim::LineSegmentIntersection(PointDWithStim p11, PointDWithStim p12, PointDWithStim p21, PointDWithStim p22)\n{\n    PointDWithStim r = (p12 - p11);\n    PointDWithStim s = (p22 - p21);\n    PointDWithStim q = p21;\n    PointDWithStim p = p11;\n    double rs = r.cross(s);\n    double eps = 1e-6;\n    if (fabs(rs) < eps)\n        return false; // lines are parallel\n    double t = (q - p).cross(s) / rs;\n    double u = (q - p).cross(r) / rs;\n    return (t>=0&&t<=1 &&u>0&&u<=1);\n}\n\n#ifndef MAX\n#define MAX(x,y)((x)>(y))?(x):(y)\n#endif\n\n#ifndef MIN\n#define MIN(x,y)((x)<(y))?(x):(y)\n#endif\n\nbool BoxWithStim::isWaveFormInside(SorterSpikeWithStimPtr so)\n{\n    PointDWithStim BoxTopLeft(x, y);\n    PointDWithStim BoxBottomLeft(x, (y - h));\n\n    PointDWithStim BoxTopRight(x + w, y);\n    PointDWithStim BoxBottomRight(x + w, (y - h));\n\n    // y,and h are given in micro volts.\n    // x and w and given in micro seconds.\n\n    // no point testing all wave form points. Just ones that are between x and x+w...\n    int BinLeft = microSecondsToSpikeTimeBin(so,x);\n    int BinRight = microSecondsToSpikeTimeBin(so,x+w);\n\n    /*\n    float minValue=1e10, maxValue=1e-10;\n    for (int pt = 0; pt < so->nSamples; pt++)\n    {\n    \tfloat v = spikeDataBinToMicrovolts(so, pt, channel);\n    \tminValue = MIN(minValue,v);\n    \tmaxValue = MAX(maxValue,v);\n    }\n    */\n\n    for (int pt = BinLeft; pt < BinRight; pt++)\n    {\n        PointDWithStim Pwave1(spikeTimeBinToMicrosecond(so,pt),spikeDataBinToMicrovolts(so, pt, channel));\n        PointDWithStim Pwave2(spikeTimeBinToMicrosecond(so,pt+1),spikeDataBinToMicrovolts(so, pt+1, channel));\n\n        bool bLeft = LineSegmentIntersection(Pwave1,Pwave2,BoxTopLeft,BoxBottomLeft) ;\n        bool bRight = LineSegmentIntersection(Pwave1,Pwave2,BoxTopRight,BoxBottomRight);\n        bool bTop = LineSegmentIntersection(Pwave1,Pwave2,BoxTopLeft,BoxTopRight);\n        bool bBottom = LineSegmentIntersection(Pwave1, Pwave2, BoxBottomLeft, BoxBottomRight);\n        if (bLeft || bRight || bTop || bBottom)\n        {\n            return true;\n        }\n\n    }\n    return false;\n}\n\n\nBoxUnitWithStim::BoxUnitWithStim()\n{\n\n}\n/**************************************/\nvoid BoxUnitWithStim::setDefaultColors(uint8_t col[3], int ID)\n{\n    int IDmodule = (ID-1) % 6; // ID can't be zero\n    const int colors[6][3] =\n    {\n        {0xFF,0xFF,0x00},\n        {0x00,0xFF,0x00},\n        {0x00, 0xFF, 0xFF},\n        {0xFF, 0x00, 0x00},\n        {0x00,0x00,0xFF},\n        {0xFF,0x00,0xFF}\n    };\n    col[0] = colors[IDmodule][0];\n    col[1] = colors[IDmodule][1];\n    col[2] = colors[IDmodule][2];\n}\n\nBoxUnitWithStim::BoxUnitWithStim(int ID, int localID_): UnitID(ID), localID(localID_)\n{\n    std::cout << \"Adding new boxWithStim unit.\" << std::endl;\n    Active = false;\n    Activated_TS_S = -1;\n    setDefaultColors(ColorRGB, localID);\n    BoxWithStim B(50, -20 - localID*20, 300, 40);\n    addBox(B);\n}\n\nvoid BoxUnitWithStim::resizeWaveform(int newlength)\n{\n    WaveformStat.resizeWaveform(newlength);\n}\n\nBoxUnitWithStim::BoxUnitWithStim(BoxWithStim B, int ID, int localID_) : UnitID(ID), localID(localID_)\n{\n    addBox(B);\n}\n\nbool BoxUnitWithStim::isWaveFormInsideAllBoxes(SorterSpikeWithStimPtr so)\n{\n    for (int k=0; k< lstBoxes.size(); k++)\n    {\n        if (!lstBoxes[k].isWaveFormInside(so))\n            return false;\n    }\n    return lstBoxes.size() == 0 ? false : true;\n}\n\nbool BoxUnitWithStim::isActivated()\n{\n    return Active;\n}\n\nvoid BoxUnitWithStim::activateUnit()\n{\n    Active = true;\n    Activated_TS_S = timer.getHighResolutionTicks();\n}\n\nvoid BoxUnitWithStim::deactivateUnit()\n{\n    Active = false;\n    Activated_TS_S = timer.getHighResolutionTicks();\n\n}\n\ndouble BoxUnitWithStim::getNumSecondsActive()\n{\n    if (!Active)\n        return 0;\n    else\n        return (timer.getHighResolutionTicks() - Activated_TS_S) / timer.getHighResolutionTicksPerSecond();\n}\n\nvoid BoxUnitWithStim::toggleActive()\n{\n    if (Active)\n        deactivateUnit();\n    else\n        activateUnit();\n}\n\nvoid BoxUnitWithStim::addBox(BoxWithStim b)\n{\n    lstBoxes.push_back(b);\n}\n\nvoid BoxUnitWithStim::addBox()\n{\n    BoxWithStim B(50 + 350 * lstBoxes.size(), -20 - UnitID * 20, 300, 40);\n    lstBoxes.push_back(B);\n}\n\nint BoxUnitWithStim::getNumBoxes()\n{\n    return (int) lstBoxes.size();\n}\n\nvoid BoxUnitWithStim::modifyBox(int boxindex, BoxWithStim b)\n{\n    lstBoxes[boxindex] = b;\n}\n\n\nbool BoxUnitWithStim::deleteBox(int boxindex)\n{\n\n    if (lstBoxes.size() > boxindex)\n    {\n        lstBoxes.erase(lstBoxes.begin()+boxindex);\n        return true;\n    }\n    return false;\n}\n\nBoxWithStim BoxUnitWithStim::getBox(int boxWithStim)\n{\n    return lstBoxes[boxWithStim];\n}\n\nvoid BoxUnitWithStim::setBox(int boxid, BoxWithStim B)\n{\n    lstBoxes[boxid].x = B.x;\n    lstBoxes[boxid].y = B.y;\n    lstBoxes[boxid].w = B.w;\n    lstBoxes[boxid].h = B.h;\n}\n\n\nvoid BoxUnitWithStim::setBoxPos(int boxid, PointDWithStim P)\n{\n    lstBoxes[boxid].x = P.X;\n    lstBoxes[boxid].y = P.Y;\n}\n\nvoid BoxUnitWithStim::setBoxSize(int boxid, double W, double H)\n{\n    lstBoxes[boxid].w = W;\n    lstBoxes[boxid].h = H;\n}\n\nvoid BoxUnitWithStim::MoveBox(int boxid, int dx, int dy)\n{\n    lstBoxes[boxid].x += dx;\n    lstBoxes[boxid].y += dy;\n}\n\nstd::vector<BoxWithStim> BoxUnitWithStim::getBoxes()\n{\n    return lstBoxes;\n}\n\n// Members\nint BoxUnitWithStim::getUnitID()\n{\n    return UnitID;\n}\n\nint BoxUnitWithStim::getLocalID()\n{\n    return localID;\n}\n\n\n/************************/\n\nHistogramWithStim::~HistogramWithStim()\n{\n    Time.clear();\n    Counter.clear();\n}\n\nHistogramWithStim::HistogramWithStim()\n{\n\n}\n\nvoid HistogramWithStim::setParameters(int N, double T0, double T1)\n{\n\n    t0 = T0;\n    t1 = T1;\n    numBins = N;\n    Time.resize(N);\n    Counter.resize(N);\n    for (int k = 0; k < N; k++)\n    {\n        Time[k] = (double)k / (N - 1) * (T1 - T0) + T0;\n        Counter[k] = 0;\n    }\n}\n\nHistogramWithStim::HistogramWithStim(int N, double T0, double T1)\n{\n    t0 = T0;\n    t1 = T1;\n    numBins = N;\n    Time.resize(N);\n    Counter.resize(N);\n    for (int k = 0; k < N; k++)\n    {\n        Time[k] = (double)k / (N - 1) * (T1 - T0) + T0;\n        Counter[k] = 0;\n    }\n}\n\nvoid HistogramWithStim::update(double x)\n{\n    int Bin = ((x - t0) / (t1 - t0) * (numBins-1));\n    if (Bin >= 0 && Bin < numBins)\n    {\n        Counter[Bin]++;\n        if (Counter[Bin] > Max)\n        {\n            Max = Counter[Bin];\n        }\n    }\n}\n\nvoid HistogramWithStim::reset()\n{\n    Max = 0;\n    for (int k = 0; k < numBins; k++)\n        Counter[k] = 0;\n}\n\nstd::vector<int> HistogramWithStim::getCounter()\n{\n    return Counter;\n}\n\n\n/**********************/\n// computes statistics about the unit (non-trial related statistics)\n\n\n\n// Running variance...\n//Mk = Mk-1+ (xk - Mk-1)/k\n//Sk = Sk-1 + (xk - Mk-1)*(xk - Mk).\n//For 2 ≤ k ≤ n, the kth estimate of the variance is s2 = Sk/(k - 1).\nRunningStatsWithStim::~RunningStatsWithStim()\n{\n}\nRunningStatsWithStim::RunningStatsWithStim()\n{\n    hist.setParameters(101, 0, 100); // Inter spike histogramWithStim. Fixed range [0..100 ms]\n    numSamples = 0;\n}\n\nvoid RunningStatsWithStim::reset()\n{\n    numSamples = 0;\n    hist.reset();\n}\n\nHistogramWithStim RunningStatsWithStim::getHistogram()\n{\n    return hist;\n}\n\nstd::vector<double> RunningStatsWithStim::getMean(int index)\n{\n    std::vector<double> m;\n\n    if (numSamples == 0)\n    {\n        return m;\n    }\n\n    int numSamplesInWaveForm = (int) WaveFormMean[0].size();\n    m.resize(numSamplesInWaveForm);\n\n    for (int k = 0; k < numSamplesInWaveForm; k++)\n        m[k] = WaveFormMean[index][k];\n    return m;\n}\n\nstd::vector<double> RunningStatsWithStim::getStandardDeviation(int index)\n{\n    std::vector<double> WaveFormVar;\n\n    if (numSamples == 0)\n    {\n        return WaveFormVar;\n    }\n    int numSamplesInWaveForm = (int) WaveFormMean[0].size();\n    WaveFormVar.resize(numSamplesInWaveForm);\n\n    for (int j = 0; j < numSamplesInWaveForm; j++)\n    {\n        if (numSamples - 1 == 0)\n            WaveFormVar[j] = 0;\n        else\n            WaveFormVar[j] = sqrt(WaveFormSk[index][j] / (numSamples - 1));\n    }\n    return WaveFormVar;\n}\n\n\nvoid RunningStatsWithStim::resizeWaveform(int newlength)\n{\n    numSamples = 0; // this should ensure that update reallocates upon the next update.\n}\n\nvoid RunningStatsWithStim::update(SorterSpikeWithStimPtr so)\n{\n    double ts = so->getTimestamp()/so->getChannel()->getSampleRate();\n    if (numSamples == 0)\n    {\n        LastSpikeTime = ts;\n    }\n    else\n    {\n        hist.update(1000.0 * (ts - LastSpikeTime));\n        LastSpikeTime = ts;\n    }\n\n    newData = true;\n\tint nChannels = so->getChannel()->getNumChannels();\n\tint nSamples = so->getChannel()->getTotalSamples();\n    if (numSamples == 0)\n    {\n        // allocate\n        WaveFormMean.resize(nChannels);\n        WaveFormSk.resize(nChannels);\n        WaveFormMk.resize(nChannels);\n        for (int k=0; k<nChannels; k++)\n        {\n            WaveFormMean[k].resize(nSamples);\n            WaveFormSk[k].resize(nSamples);\n            WaveFormMk[k].resize(nSamples);\n        }\n\n        for (int i = 0; i < nChannels; i++)\n        {\n            for (int j = 0; j < nSamples; j++)\n            {\n\t\t\t\tWaveFormMean[i][j] = so->getData()[j + i*nSamples];\n                WaveFormSk[i][j] = 0;\n\t\t\t\tWaveFormMk[i][j] = so->getData()[j + i*nSamples];\n            }\n        }\n        numSamples += 1.0F;\n        return;\n    }\n    // running mean\n    for (int i = 0; i < nChannels; i++)\n    {\n        for (int j = 0; j < nSamples; j++)\n        {\n\t\t\tWaveFormMean[i][j] = (numSamples * WaveFormMean[i][j] + so->getData()[j + i*nSamples]) / (numSamples + 1);\n\t\t\tWaveFormMk[i][j] += (so->getData()[j + i*nSamples] - WaveFormMk[i][j]) / numSamples;\n\t\t\tWaveFormSk[i][j] += (so->getData()[j + i*nSamples] - WaveFormMk[i][j]) * (so->getData()[j + i*nSamples] - WaveFormMk[i][j]);\n        }\n    }\n    numSamples += 1.0F;\n}\n\n\nbool RunningStatsWithStim::queryNewData()\n{\n    if (newData == false)\n        return false;\n    newData = false;\n    return true;\n}\n\nvoid BoxUnitWithStim::updateWaveform(SorterSpikeWithStimPtr so)\n{\n    WaveformStat.update(so);\n}\n\n\n/*\n        public bool QueryNewData()\n        {\n            return WaveFormStat.QueryNewData();\n        }\n\n        public HistogramWithStim GetInterSpikeHistogram()\n        {\n            return WaveFormStat.GetHistogram();\n        }\n\n        public void GetWaveFormMeanStd(out double[] Mean, out double[] Std, int index)\n        {\n            Mean = WaveFormStat.GetMean(index);\n            Std = WaveFormStat.GetStandardDeviation(index);\n        }\n\n        public void ResetWaveForm()\n        {\n            WaveFormStat.Reset();\n        }\n\n\n    }\n\t*/\n\n/***********************************************/\n\nSpikeSortBoxesWithStim::SpikeSortBoxesWithStim(UniqueIDgeneratorWithStim* uniqueIDgenerator_,PCAcomputingThreadWithStim* pth, int numch, double SamplingRate, int WaveFormLength)\n{\n    uniqueIDgenerator = uniqueIDgenerator_;\n    computingThread = pth;\n    pc1 = pc2 = nullptr;\n    bufferSize = 200;\n    spikeBufferIndex = -1;\n    bPCAcomputed = false;\n    bPCAJobSubmitted = false;\n    bPCAjobFinished = false;\n    selectedUnit = -1;\n    selectedBox = -1;\n    bRePCA = false;\n    pc1min = -1;\n    pc2min = -1;\n    pc1max = 1;\n    pc2max = 1;\n    numChannels = numch;\n    waveformLength = WaveFormLength;\n\n    pc1 = new float[numChannels * waveformLength];\n    pc2 = new float[numChannels * waveformLength];\n    for (int n = 0; n < bufferSize; n++)\n    {\n\n        spikeBuffer.add(nullptr);\n    }\n}\n\nvoid SpikeSortBoxesWithStim::resizeWaveform(int numSamples)\n{\n    const ScopedLock myScopedLock(mut);\n    //StartCriticalSection();\n    waveformLength = numSamples;\n    delete[] pc1;\n    delete[] pc2;\n    pc1 = new float[numChannels * waveformLength];\n    pc2 = new float[numChannels * waveformLength];\n    spikeBuffer.clear();\n    for (int n = 0; n < bufferSize; n++)\n    {\n        spikeBuffer.add(nullptr);\n    }\n    bPCAcomputed = false;\n    spikeBufferIndex = -1;\n\tbPCAJobSubmitted = false;\n\tbPCAjobFinished = false;\n\tselectedUnit = -1;\n\tselectedBox = -1;\n\tbRePCA = false;\n\tpc1min = -1;\n\tpc2min = -1;\n\tpc1max = 1;\n\tpc2max = 1;\n\n    for (int k=0; k<pcaUnits.size(); k++)\n    {\n        pcaUnits[k].resizeWaveform(waveformLength);\n    }\n    for (int k=0; k<boxUnits.size(); k++)\n    {\n        boxUnits[k].resizeWaveform(waveformLength);\n    }\n    //EndCriticalSection();\n}\n\n\n\nvoid SpikeSortBoxesWithStim::loadCustomParametersFromXml(XmlElement* electrodeNode)\n{\n\n    forEachXmlChildElement(*electrodeNode, spikesortNode)\n    {\n        if (spikesortNode->hasTagName(\"SPIKESORTING\"))\n        {\n            //int numBoxUnit  = spikesortNode->getIntAttribute(\"numBoxUnits\");\n            //int numPCAUnit  = spikesortNode->getIntAttribute(\"numPCAUnits\");\n            selectedUnit  = spikesortNode->getIntAttribute(\"selectedUnit\");\n            selectedBox =  spikesortNode->getIntAttribute(\"selectedBox\");\n\n\n            pcaUnits.clear();\n            boxUnits.clear();\n\n            forEachXmlChildElement(*spikesortNode, UnitNode)\n            {\n                if (UnitNode->hasTagName(\"PCA\"))\n                {\n                    numChannels = UnitNode->getIntAttribute(\"numChannels\");\n                    waveformLength = UnitNode->getIntAttribute(\"waveformLength\");\n\n                    pc1min = UnitNode->getDoubleAttribute(\"pc1min\");\n                    pc2min = UnitNode->getDoubleAttribute(\"pc2min\");\n                    pc1max = UnitNode->getDoubleAttribute(\"pc1max\");\n                    pc2max = UnitNode->getDoubleAttribute(\"pc2max\");\n\n                    bPCAjobFinished = UnitNode->getBoolAttribute(\"PCAjobFinished\");\n                    bPCAcomputed = UnitNode->getBoolAttribute(\"PCAcomputed\");\n\n                    delete[] pc1;\n                    delete[] pc2;\n\n                    pc1 = new float[waveformLength*numChannels];\n                    pc2 = new float[waveformLength*numChannels];\n                    int dimcounter = 0;\n                    forEachXmlChildElement(*UnitNode, dimNode)\n                    {\n                        if (dimNode->hasTagName(\"PCA_DIM\"))\n                        {\n                            pc1[dimcounter]=dimNode->getDoubleAttribute(\"pc1\");\n                            pc2[dimcounter]=dimNode->getDoubleAttribute(\"pc2\");\n                            dimcounter++;\n                        }\n                    }\n                }\n\n                if (UnitNode->hasTagName(\"BOXUNIT\"))\n                {\n                    BoxUnitWithStim boxUnitWithStim;\n                    boxUnitWithStim.UnitID = UnitNode->getIntAttribute(\"UnitID\");\n                    boxUnitWithStim.ColorRGB[0] = UnitNode->getIntAttribute(\"ColorR\");\n                    boxUnitWithStim.ColorRGB[1] = UnitNode->getIntAttribute(\"ColorG\");\n                    boxUnitWithStim.ColorRGB[2] = UnitNode->getIntAttribute(\"ColorB\");\n                    int numBoxes = UnitNode->getIntAttribute(\"NumBoxes\");\n                    boxUnitWithStim.lstBoxes.resize(numBoxes);\n                    int boxCounter = 0;\n                    forEachXmlChildElement(*UnitNode, boxNode)\n                    {\n                        if (boxNode->hasTagName(\"BOXWithStim\"))\n                        {\n                            BoxWithStim boxWithStim;\n                            boxWithStim.channel = boxNode->getIntAttribute(\"ch\");\n                            boxWithStim.x = boxNode->getDoubleAttribute(\"x\");\n                            boxWithStim.y = boxNode->getDoubleAttribute(\"y\");\n                            boxWithStim.w = boxNode->getDoubleAttribute(\"w\");\n                            boxWithStim.h = boxNode->getDoubleAttribute(\"h\");\n                            boxUnitWithStim.lstBoxes[boxCounter++] = boxWithStim;\n                        }\n                    }\n                    // add boxWithStim unit\n                    boxUnits.push_back(boxUnitWithStim);\n                }\n                if (UnitNode->hasTagName(\"PCAUNIT\"))\n                {\n                    PCAUnitWithStim pcaUnit;\n\n                    pcaUnit.UnitID = UnitNode->getIntAttribute(\"UnitID\");\n                    pcaUnit.ColorRGB[0] = UnitNode->getIntAttribute(\"ColorR\");\n                    pcaUnit.ColorRGB[1] = UnitNode->getIntAttribute(\"ColorG\");\n                    pcaUnit.ColorRGB[2] = UnitNode->getIntAttribute(\"ColorB\");\n\n                    int numPolygonPoints = UnitNode->getIntAttribute(\"PolygonNumPoints\");\n                    pcaUnit.poly.pts.resize(numPolygonPoints);\n                    pcaUnit.poly.offset.X = UnitNode->getDoubleAttribute(\"PolygonOffsetX\");\n                    pcaUnit.poly.offset.Y = UnitNode->getDoubleAttribute(\"PolygonOffsetY\");\n                    // read polygon\n                    int pointCounter = 0;\n                    forEachXmlChildElement(*UnitNode, polygonPoint)\n                    {\n                        if (polygonPoint->hasTagName(\"POLYGON_POINT\"))\n                        {\n                            pcaUnit.poly.pts[pointCounter].X =  polygonPoint->getDoubleAttribute(\"pointX\");\n                            pcaUnit.poly.pts[pointCounter].Y =  polygonPoint->getDoubleAttribute(\"pointY\");\n                            pointCounter++;\n                        }\n                    }\n                    // add polygon unit\n                    pcaUnits.push_back(pcaUnit);\n                }\n            }\n        }\n    }\n}\n\nvoid SpikeSortBoxesWithStim::saveCustomParametersToXml(XmlElement* electrodeNode)\n{\n\n    XmlElement* spikesortNode = electrodeNode->createNewChildElement(\"SPIKESORTING\");\n    spikesortNode->setAttribute(\"numBoxUnits\", (int)boxUnits.size());\n    spikesortNode->setAttribute(\"numPCAUnits\", (int)pcaUnits.size());\n    spikesortNode->setAttribute(\"selectedUnit\",selectedUnit);\n    spikesortNode->setAttribute(\"selectedBox\",selectedBox);\n\n\n    XmlElement* pcaNode = electrodeNode->createNewChildElement(\"PCA\");\n    pcaNode->setAttribute(\"numChannels\",numChannels);\n    pcaNode->setAttribute(\"waveformLength\",waveformLength);\n    pcaNode->setAttribute(\"pc1min\", pc1min);\n    pcaNode->setAttribute(\"pc2min\", pc2min);\n    pcaNode->setAttribute(\"pc1max\", pc1max);\n    pcaNode->setAttribute(\"pc2max\", pc2max);\n\n    pcaNode->setAttribute(\"PCAjobFinished\", bPCAjobFinished);\n    pcaNode->setAttribute(\"PCAcomputed\", bPCAcomputed);\n\n    for (int k=0; k<numChannels*waveformLength; k++)\n    {\n        XmlElement* dimNode = pcaNode->createNewChildElement(\"PCA_DIM\");\n        dimNode->setAttribute(\"pc1\",pc1[k]);\n        dimNode->setAttribute(\"pc2\",pc2[k]);\n    }\n\n    for (int boxUnitIter=0; boxUnitIter<boxUnits.size(); boxUnitIter++)\n    {\n        XmlElement* BoxUnitNode = spikesortNode->createNewChildElement(\"BOXUNITWithStim\");\n\n        BoxUnitNode->setAttribute(\"UnitID\",boxUnits[boxUnitIter].UnitID);\n        BoxUnitNode->setAttribute(\"ColorR\",boxUnits[boxUnitIter].ColorRGB[0]);\n        BoxUnitNode->setAttribute(\"ColorG\",boxUnits[boxUnitIter].ColorRGB[1]);\n        BoxUnitNode->setAttribute(\"ColorB\",boxUnits[boxUnitIter].ColorRGB[2]);\n        BoxUnitNode->setAttribute(\"NumBoxes\", (int)boxUnits[boxUnitIter].lstBoxes.size());\n        for (int boxIter=0; boxIter<boxUnits[boxUnitIter].lstBoxes.size(); boxIter++)\n        {\n            XmlElement* BoxNode = BoxUnitNode->createNewChildElement(\"BOXWithStim\");\n            BoxNode->setAttribute(\"ch\", (int)boxUnits[boxUnitIter].lstBoxes[boxIter].channel);\n            BoxNode->setAttribute(\"x\", (int)boxUnits[boxUnitIter].lstBoxes[boxIter].x);\n            BoxNode->setAttribute(\"y\", (int)boxUnits[boxUnitIter].lstBoxes[boxIter].y);\n            BoxNode->setAttribute(\"w\", (int)boxUnits[boxUnitIter].lstBoxes[boxIter].w);\n            BoxNode->setAttribute(\"h\", (int)boxUnits[boxUnitIter].lstBoxes[boxIter].h);\n        }\n    }\n\n    for (int pcaUnitIter=0; pcaUnitIter<pcaUnits.size(); pcaUnitIter++)\n    {\n        XmlElement* PcaUnitNode = spikesortNode->createNewChildElement(\"PCAUNIT\");\n\n        PcaUnitNode->setAttribute(\"UnitID\",pcaUnits[pcaUnitIter].UnitID);\n        PcaUnitNode->setAttribute(\"ColorR\",pcaUnits[pcaUnitIter].ColorRGB[0]);\n        PcaUnitNode->setAttribute(\"ColorG\",pcaUnits[pcaUnitIter].ColorRGB[1]);\n        PcaUnitNode->setAttribute(\"ColorB\",pcaUnits[pcaUnitIter].ColorRGB[2]);\n        PcaUnitNode->setAttribute(\"PolygonNumPoints\",(int)pcaUnits[pcaUnitIter].poly.pts.size());\n        PcaUnitNode->setAttribute(\"PolygonOffsetX\",(int)pcaUnits[pcaUnitIter].poly.offset.X);\n        PcaUnitNode->setAttribute(\"PolygonOffsetY\",(int)pcaUnits[pcaUnitIter].poly.offset.Y);\n\n        for (int p=0; p<pcaUnits[pcaUnitIter].poly.pts.size(); p++)\n        {\n            XmlElement* PolygonNode = PcaUnitNode->createNewChildElement(\"POLYGON_POINT\");\n            PolygonNode->setAttribute(\"pointX\", pcaUnits[pcaUnitIter].poly.pts[p].X);\n            PolygonNode->setAttribute(\"pointY\", pcaUnits[pcaUnitIter].poly.pts[p].Y);\n        }\n    }\n\n\n    //float *pc1, *pc2;\n\n\n}\n\nSpikeSortBoxesWithStim::~SpikeSortBoxesWithStim()\n{\n    // wait until PCA job is done (if one was submitted).\n    delete[] pc1;\n    delete[] pc2;\n    pc1 = nullptr;\n    pc2 = nullptr;\n}\n\nvoid SpikeSortBoxesWithStim::setSelectedUnitAndBox(int unitID, int boxID)\n{\n    selectedUnit = unitID;\n    selectedBox = boxID;\n}\n\nvoid SpikeSortBoxesWithStim::getSelectedUnitAndBox(int& unitID, int& boxid)\n{\n    unitID = selectedUnit;\n    boxid = selectedBox;\n}\n\nvoid SpikeSortBoxesWithStim::projectOnPrincipalComponents(SorterSpikeWithStimPtr so)\n{\n    spikeBufferIndex++;\n    spikeBufferIndex %= bufferSize;\n    spikeBuffer.set(spikeBufferIndex, so);\n    if (bPCAjobFinished)\n    {\n        bPCAcomputed = true;\n    }\n\n    if (bPCAcomputed)\n    {\n        so->pcProj[0] = so->pcProj[1] = 0;\n        for (int k=0; k<so->getChannel()->getNumChannels()*so->getChannel()->getTotalSamples(); k++)\n        {\n            float v = spikeDataIndexToMicrovolts(so, k);\n            so->pcProj[0] += pc1[k]* v;\n            so->pcProj[1] += pc2[k]* v;\n        }\n        if (so->pcProj[0] > 1e5 || so->pcProj[0] < -1e5 || so->pcProj[1] > 1e5 || so->pcProj[1] < -1e5)\n        {\n            //int dbg = 1;\n        }\n    }\n    else\n    {\n        // add a spike object to the buffer.\n        // if we have enough spikes, start the PCA computation thread.\n        if ((spikeBufferIndex == bufferSize -1 && !bPCAcomputed && !bPCAJobSubmitted) || bRePCA)\n        {\n            bPCAJobSubmitted = true;\n\t    bPCAcomputed = false;\n            bRePCA = false;\n            // submit a new job to compute the spike buffer.\n            PCAJobWithStimPtr job = new PCAjobWithStim(spikeBuffer,pc1,pc2, pc1min, pc2min, pc1max, pc2max, bPCAjobFinished);\n            computingThread->addPCAjob(job);\n        }\n    }\n}\n\nvoid SpikeSortBoxesWithStim::getPCArange(float& p1min,float& p2min, float& p1max,  float& p2max)\n{\n    p1min = pc1min;\n    p2min = pc2min;\n    p1max = pc1max;\n    p2max = pc2max;\n}\n\nvoid SpikeSortBoxesWithStim::setPCArange(float p1min,float p2min, float p1max,  float p2max)\n{\n    pc1min=p1min;\n    pc2min=p2min;\n    pc1max=p1max;\n    pc2max=p2max;\n}\n\n\nvoid SpikeSortBoxesWithStim::resetJobStatus()\n{\n    bPCAjobFinished = false;\n}\n\nbool SpikeSortBoxesWithStim::isPCAfinished()\n{\n    return bPCAjobFinished;\n}\nvoid SpikeSortBoxesWithStim::RePCA()\n{\n    bPCAcomputed = false;\n    bPCAJobSubmitted = false;\n    bRePCA = true;\n}\n\nvoid SpikeSortBoxesWithStim::addPCAunit(PCAUnitWithStim unit)\n{\n    const ScopedLock myScopedLock(mut);\n    //StartCriticalSection();\n    pcaUnits.push_back(unit);\n    //EndCriticalSection();\n}\n\n// Adds a new unit with a single boxWithStim at some default location.\n// returns the unit id\nint SpikeSortBoxesWithStim::addBoxUnit(int channel)\n{\n    const ScopedLock myScopedLock(mut);\n    //StartCriticalSection();\n    int unusedID = uniqueIDgenerator->generateUniqueID(); //generateUnitID();\n    BoxUnitWithStim unit(unusedID, generateLocalID());\n    boxUnits.push_back(unit);\n    setSelectedUnitAndBox(unusedID, 0);\n    //EndCriticalSection();\n    return unusedID;\n}\n/*\nvoid  SpikeSortBoxesWithStim::StartCriticalSection()\n{\n\tmut.enter();\n}\n\nvoid  SpikeSortBoxesWithStim::EndCriticalSection()\n{\n\tmut.exit();\n}\n*/\nint SpikeSortBoxesWithStim::addBoxUnit(int channel, BoxWithStim B)\n{\n    const ScopedLock myScopedLock(mut);\n    //StartCriticalSection();\n    int unusedID = uniqueIDgenerator->generateUniqueID(); //generateUnitID();\n    BoxUnitWithStim unit(B, unusedID,generateLocalID());\n    boxUnits.push_back(unit);\n    setSelectedUnitAndBox(unusedID, 0);\n    //EndCriticalSection();\n    return unusedID;\n}\n\nvoid SpikeSortBoxesWithStim::getUnitColor(int UnitID, uint8& R, uint8& G, uint8& B)\n{\n    for (int k = 0; k < boxUnits.size(); k++)\n    {\n        if (boxUnits[k].getUnitID() == UnitID)\n        {\n            R = boxUnits[k].ColorRGB[0];\n            G = boxUnits[k].ColorRGB[1];\n            B = boxUnits[k].ColorRGB[2];\n            break;\n        }\n    }\n    for (int k = 0; k < pcaUnits.size(); k++)\n    {\n        if (pcaUnits[k].getUnitID() == UnitID)\n        {\n            R = pcaUnits[k].ColorRGB[0];\n            G = pcaUnits[k].ColorRGB[1];\n            B = pcaUnits[k].ColorRGB[2];\n            break;\n        }\n    }\n}\n\nint SpikeSortBoxesWithStim::generateLocalID()\n{\n    // finds the first unused ID and return it\n\n    int ID = 1;\n\n    while (true)\n    {\n        bool used=false;\n        for (int k = 0; k < boxUnits.size(); k++)\n        {\n            if (boxUnits[k].getLocalID() == ID)\n            {\n                used = true;\n                break;\n            }\n        }\n        for (int k = 0; k < pcaUnits.size(); k++)\n        {\n            if (pcaUnits[k].getLocalID() == ID)\n            {\n                used = true;\n                break;\n            }\n        }\n\n        if (used)\n            ID++;\n        else\n            break;\n    }\n    return ID;\n}\n\nint SpikeSortBoxesWithStim::generateUnitID()\n{\n\n    int ID = uniqueIDgenerator->generateUniqueID();\n    return ID;\n}\n\n\nvoid SpikeSortBoxesWithStim::generateNewIDs()\n{\n    const ScopedLock myScopedLock(mut);\n    for (int k=0; k<boxUnits.size(); k++)\n    {\n        boxUnits[k].UnitID = generateUnitID();\n    }\n    for (int k=0; k<pcaUnits.size(); k++)\n    {\n        pcaUnits[k].UnitID = generateUnitID();\n    }\n}\n\nvoid SpikeSortBoxesWithStim::removeAllUnits()\n{\n    const ScopedLock myScopedLock(mut);\n    boxUnits.clear();\n    pcaUnits.clear();\n}\n\nbool SpikeSortBoxesWithStim::removeUnit(int unitID)\n{\n    const ScopedLock myScopedLock(mut);\n    //StartCriticalSection();\n    for (int k=0; k<boxUnits.size(); k++)\n    {\n        if (boxUnits[k].getUnitID() == unitID)\n        {\n            boxUnits.erase(boxUnits.begin()+k);\n            //EndCriticalSection();\n            return true;\n        }\n    }\n\n    for (int k=0; k<pcaUnits.size(); k++)\n    {\n        if (pcaUnits[k].getUnitID() == unitID)\n        {\n            pcaUnits.erase(pcaUnits.begin()+k);\n            //EndCriticalSection();\n            return true;\n        }\n    }\n\n    // EndCriticalSection();\n    return false;\n\n}\n\nbool SpikeSortBoxesWithStim::addBoxToUnit(int channel, int unitID)\n{\n    const ScopedLock myScopedLock(mut);\n\n    //StartCriticalSection();\n\n    for (int k = 0; k < boxUnits.size(); k++)\n    {\n        if (boxUnits[k].getUnitID() == unitID)\n        {\n            BoxWithStim B = boxUnits[k].lstBoxes[boxUnits[k].lstBoxes.size() - 1];\n            B.x += 100;\n            B.y -= 30;\n            B.channel = channel;\n            boxUnits[k].addBox(B);\n            setSelectedUnitAndBox(unitID, (int) boxUnits[k].lstBoxes.size() - 1);\n            // EndCriticalSection();\n            return true;\n        }\n    }\n    // EndCriticalSection();\n    return false;\n}\n\n\nbool SpikeSortBoxesWithStim::addBoxToUnit(int channel, int unitID, BoxWithStim B)\n{\n    const ScopedLock myScopedLock(mut);\n    //StartCriticalSection();\n    for (int k=0; k<boxUnits.size(); k++)\n    {\n        if (boxUnits[k].getUnitID() == unitID)\n        {\n            boxUnits[k].addBox(B);\n            // EndCriticalSection();\n            return true;\n        }\n    }\n    //EndCriticalSection();\n    return false;\n}\n\nstd::vector<BoxUnitWithStim> SpikeSortBoxesWithStim::getBoxUnits()\n{\n    //StartCriticalSection();\n    const ScopedLock myScopedLock(mut);\n    std::vector<BoxUnitWithStim> unitsCopy = boxUnits;\n    //EndCriticalSection();\n    return unitsCopy;\n}\n\n\nstd::vector<PCAUnitWithStim> SpikeSortBoxesWithStim::getPCAUnits()\n{\n    //StartCriticalSection();\n    const ScopedLock myScopedLock(mut);\n    std::vector<PCAUnitWithStim> unitsCopy = pcaUnits;\n    //EndCriticalSection();\n    return unitsCopy;\n}\n\nvoid SpikeSortBoxesWithStim::updatePCAUnits(std::vector<PCAUnitWithStim> _units)\n{\n    //StartCriticalSection();\n    const ScopedLock myScopedLock(mut);\n    pcaUnits = _units;\n    //EndCriticalSection();\n}\n\nvoid SpikeSortBoxesWithStim::updateBoxUnits(std::vector<BoxUnitWithStim> _units)\n{\n    const ScopedLock myScopedLock(mut);\n    //StartCriticalSection();\n    boxUnits = _units;\n    //EndCriticalSection();\n}\n\n\n\n\n// tests whether a candidate spike belongs to one of the defined units\nbool SpikeSortBoxesWithStim::sortSpike(SorterSpikeWithStimPtr so, bool PCAfirst)\n{\n    const ScopedLock myScopedLock(mut);\n    if (PCAfirst)\n    {\n\n        for (int k=0; k<pcaUnits.size(); k++)\n        {\n            if (pcaUnits[k].isWaveFormInsidePolygon(so))\n            {\n                so->sortedId = pcaUnits[k].getUnitID();\n                so->color[0] = pcaUnits[k].ColorRGB[0];\n                so->color[1] = pcaUnits[k].ColorRGB[1];\n                so->color[2] = pcaUnits[k].ColorRGB[2];\n                return true;\n            }\n        }\n\n        for (int k=0; k<boxUnits.size(); k++)\n        {\n            if (boxUnits[k].isWaveFormInsideAllBoxes(so))\n            {\n                so->sortedId = boxUnits[k].getUnitID();\n                so->color[0] = boxUnits[k].ColorRGB[0];\n                so->color[1] = boxUnits[k].ColorRGB[1];\n                so->color[2] = boxUnits[k].ColorRGB[2];\n                boxUnits[k].updateWaveform(so);\n                return true;\n            }\n        }\n    }\n    else\n    {\n\n        for (int k=0; k<boxUnits.size(); k++)\n        {\n            if (boxUnits[k].isWaveFormInsideAllBoxes(so))\n            {\n                so->sortedId = boxUnits[k].getUnitID();\n                so->color[0] = boxUnits[k].ColorRGB[0];\n                so->color[1] = boxUnits[k].ColorRGB[1];\n                so->color[2] = boxUnits[k].ColorRGB[2];\n                boxUnits[k].updateWaveform(so);\n                return true;\n            }\n        }\n        for (int k=0; k<pcaUnits.size(); k++)\n        {\n            if (pcaUnits[k].isWaveFormInsidePolygon(so))\n            {\n                so->sortedId = pcaUnits[k].getUnitID();\n                so->color[0] = pcaUnits[k].ColorRGB[0];\n                so->color[1] = pcaUnits[k].ColorRGB[1];\n                so->color[2] = pcaUnits[k].ColorRGB[2];\n                pcaUnits[k].updateWaveform(so);\n                return true;\n            }\n        }\n\n    }\n\n    return false;\n}\n\n\nbool  SpikeSortBoxesWithStim::removeBoxFromUnit(int unitID, int boxIndex)\n{\n    const ScopedLock myScopedLock(mut);\n    //StartCriticalSection();\n    for (int k=0; k<boxUnits.size(); k++)\n    {\n        if (boxUnits[k].getUnitID() == unitID)\n        {\n            bool s= boxUnits[k].deleteBox(boxIndex);\n            setSelectedUnitAndBox(-1,-1);\n            //EndCriticalSection();\n            return s;\n        }\n\n    }\n\n    //EndCriticalSection();\n    return false;\n}\n\nstd::vector<BoxWithStim> SpikeSortBoxesWithStim::getUnitBoxes(int unitID)\n{\n    std::vector<BoxWithStim> boxes;\n    const ScopedLock myScopedLock(mut);\n    //StartCriticalSection();\n    for (int k=0; k< boxUnits.size(); k++)\n    {\n        if (boxUnits[k].getUnitID() == unitID)\n        {\n\n            boxes = boxUnits[k].getBoxes();\n            // EndCriticalSection();\n            return boxes;\n        }\n    }\n    //EndCriticalSection();\n    return boxes;\n}\n\n\nint SpikeSortBoxesWithStim::getNumBoxes(int unitID)\n{\n    const ScopedLock myScopedLock(mut);\n    // StartCriticalSection();\n    for (int k=0; k< boxUnits.size(); k++)\n    {\n        if (boxUnits[k].getUnitID() == unitID)\n        {\n\n            int n =boxUnits[k].getNumBoxes();\n            // EndCriticalSection();\n            return n;\n        }\n    }\n    //EndCriticalSection();\n    return -1;\n}\n\n/*\n        public void DrawBoxes(BufferedGraphics buf, int channel, int SelectedUnit, int SelectedBox,\n            double XScale, double XOffset, double YScale, double YOffset)\n        {\n            mut.WaitOne();\n            int unitcounter=0;\n            foreach (BoxUnitWithStim unit in lstChannelUnits[channel])\n            {\n                Pen myPen = new Pen(unit.ColorRGB);\n                int boxcounter =0;\n                foreach (BoxWithStim b in unit.getBoxes())\n                {\n                    if (unit.GetUnitID() == SelectedUnit && SelectedBox == boxcounter)\n                    {\n                        myPen.Width = 3;\n\n                    }\n                    else\n                    {\n                        myPen.Width = 1;\n                    }\n\n                   buf.Graphics.DrawRectangle(myPen, (float)(b.x * XScale + XOffset),\n                                                      (float)(YOffset-YScale*b.y),\n                                                      (float)((b.w) * XScale),\n                                                      (float)(YScale*b.h));\n                    boxcounter++;\n                }\n                unitcounter++;\n            }\n            mut.ReleaseMutex();\n        }\n\n        public bool IsUnitActivated(int channel, int unitID)\n        {\n            foreach (BoxUnitWithStim unit in lstChannelUnits[channel])\n                if (unit.GetUnitID() == unitID)\n                    return unit.IsActivated();\n            return false;\n        }\n\n        public void ActivateUnit(int channel, int unitID)\n        {\n            foreach (BoxUnitWithStim unit in lstChannelUnits[channel])\n                if (unit.GetUnitID() == unitID)\n                     unit.ActivateUnit();\n        }\n        public void DectivateUnit(int channel, int unitID)\n        {\n            foreach (BoxUnitWithStim unit in lstChannelUnits[channel])\n                if (unit.GetUnitID() == unitID)\n                    unit.DeactivateUnit();\n        }\n        public double GetNumSecUnitActive(int channel, int unitID)\n        {\n            foreach (BoxUnitWithStim unit in lstChannelUnits[channel])\n                if (unit.GetUnitID() == unitID)\n                    return unit.GetNumSecondsActive();\n\n            return 0;\n        }\n        public void ToggleActivate(int channel, int unitID)\n        {\n            foreach (BoxUnitWithStim unit in lstChannelUnits[channel])\n                if (unit.GetUnitID() == unitID)\n                    unit.ToggleActive();\n        }\n\n\n        public void UpdateUnitBoxPos(int channel, int unitID, int boxID, PointDWithStim P)\n        {\n            foreach (BoxUnitWithStim unit in lstChannelUnits[channel])\n            if (unit.GetUnitID() == unitID)\n                unit.SetBoxPos(boxID,P);\n        }\n\n        public void UpdateUnitBoxPosAndSize(int channel, int unitID, int boxID, BoxWithStim B)\n        {\n            foreach (BoxUnitWithStim unit in lstChannelUnits[channel])\n                if (unit.GetUnitID() == unitID)\n                    unit.SetBox(boxID, B);\n        }\n\n\n        //YScaleFactors[yScaleIndex]\n        public void DrawWavesInBuffer(BufferedGraphics buf, int channel, double XScale, double YScale, double YOffset)\n        {\n            mut.WaitOne();\n            foreach (WaveForm wf in WaveFormBuffer[channel])\n            {\n                Pen myPen = new Pen(wf.colorRGB);\n                for (int j = 0; j < wf.numpts - 1; j++)\n                {\n                    buf.Graphics.DrawLine(myPen,\n                        (float)(XScale * j),\n                        (float)(YOffset - YScale * wf.Wave[wf.detected_on_channel_index, j]),\n                        (float)(XScale * (j + 1)), (float)(YOffset - YScale * wf.Wave[wf.detected_on_channel_index, j + 1]));\n                }\n            }\n            mut.ReleaseMutex();\n        }\n\n         public void ClearAvgWaveForm(int channel, int UnitID)\n        {\n            foreach (BoxUnitWithStim unit in lstChannelUnits[channel])\n            {\n                if (unit.GetUnitID() == UnitID)\n                {\n                    unit.ResetWaveForm();\n                    return;\n                }\n            }\n        }\n\n        public void GetWaveFormsMeanVar(int Channel, out double[,] Mean, out double[,] Std, out int[] UnitIDs, out Boolean[] HasData)\n        {\n            mut.WaitOne();\n            int Counter=0,dim1;\n            if (WaveFormBuffer[0].Count == 0)\n                dim1 = 62;\n            else\n                dim1 = WaveFormBuffer[0][0].Wave.GetLength(1);\n\n            HasData = new Boolean[lstChannelUnits[Channel].Count];\n            Mean = new double[lstChannelUnits[Channel].Count,dim1];\n            Std =  new double[lstChannelUnits[Channel].Count,dim1];\n            UnitIDs = new int[lstChannelUnits[Channel].Count];\n            foreach (BoxUnitWithStim unit in lstChannelUnits[Channel])\n            {\n                double[] MeanUnit, StdUnit;\n                HasData[Counter] = false;\n                UnitIDs[Counter] = unit.GetUnitID();\n                unit.GetWaveFormMeanStd(out MeanUnit, out StdUnit, 0);\n                if (MeanUnit == null)\n                {\n                    Counter++;\n                    continue;\n                }\n                HasData[Counter] = true;\n                for (int j = 0; j < dim1; j++)\n                {\n                    Mean[Counter,j] = MeanUnit[j];\n                    Std[Counter, j] = StdUnit[j];\n                }\n\n                Counter++;\n            }\n            mut.ReleaseMutex();\n        }\n\n\n        private bool GetUnit(int Channel, int UnitID, out BoxUnitWithStim boxWithStim)\n        {\n            boxWithStim = new BoxUnitWithStim(0);\n            foreach (BoxUnitWithStim unit in lstChannelUnits[Channel])\n            {\n                if (unit.GetUnitID() == UnitID)\n                {\n                    boxWithStim = unit;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public void DrawInterSpikeHistogram(int channel, int UnitID, BufferedGraphics buf, int Width, int Height)\n        {\n            mut.WaitOne();\n            BoxUnitWithStim unit;\n            if (!GetUnit(channel, UnitID, out unit))\n            {\n                mut.ReleaseMutex();\n                return;\n            }\n\n            Color FadedColor = Color.FromArgb(unit.ColorRGB.A, unit.ColorRGB.R / 2, unit.ColorRGB.G / 2, unit.ColorRGB.B / 2);\n            Pen myPen = new Pen(FadedColor);\n\n            int NumPointsToDraw = 30;\n            float XScale = (float)Width / NumPointsToDraw;\n            HistogramWithStim hist = unit.GetInterSpikeHistogram();\n            SolidBrush myBrush = new SolidBrush(FadedColor);\n            SolidBrush myRedBrush = new SolidBrush(Color.Red);\n            if (hist.Max > 0)\n            {\n                float YScale = (float)Height / hist.Max;\n\n                 for (int j = 0; j < NumPointsToDraw - 1; j++)\n                {\n                     if (j > 2)\n                        buf.Graphics.FillRectangle(myBrush, new Rectangle((int)(XScale * (j + 0.5)), (int)(Height - YScale * hist.Counter[j]), (int)(Width / NumPointsToDraw), (int)(YScale * hist.Counter[j])));\n                     else\n                         buf.Graphics.FillRectangle(myRedBrush, new Rectangle((int)(XScale * (j + 0.5)), (int)(Height - YScale * hist.Counter[j]), (int)(Width / NumPointsToDraw), (int)(YScale * hist.Counter[j])));\n\n                }\n            }\n            mut.ReleaseMutex();\n        }\n\n\n        public void DrawAvgWaveForm(int channel, int UnitID, BufferedGraphics buf, int Width, int Height, double YScale )\n        {\n            BoxUnitWithStim unit;\n            mut.WaitOne();\n            if (!GetUnit(channel, UnitID, out unit))\n            {\n                mut.ReleaseMutex();\n                return;\n            }\n\n            double [] Mean;\n            double [] Std;\n            unit.GetWaveFormMeanStd(out Mean, out Std, 0);\n            if (Mean == null)\n            {\n                mut.ReleaseMutex();\n                return;\n            }\n\n\n            Pen myPen = new Pen(unit.ColorRGB);\n            Pen myDashPen = new Pen(unit.ColorRGB);\n            myDashPen.DashStyle = System.Drawing.Drawing2D.DashStyle.DashDot;\n\n            int WaveFormLength = Mean.Length;\n            float XScale = (float)Width / 62.0F;\n            float YOffset = (float)Height / 2.0F;\n\n            for (int j = 0; j < WaveFormLength - 1; j++)\n            {\n                buf.Graphics.DrawLine(myPen,\n                    (float)(XScale * j),\n                    (float)(YOffset - YScale * Mean[j]),\n                    (float)(XScale * (j + 1)), (float)(YOffset - YScale * Mean[j + 1]));\n\n                buf.Graphics.DrawLine(myDashPen,\n                                   (float)(XScale * j),\n                                   (float)(YOffset - YScale * (Std[ j] + Mean[ j])),\n                                   (float)(XScale * (j + 1)), (float)(YOffset - YScale * (Std[ j + 1] +Mean[ j + 1])));\n\n                buf.Graphics.DrawLine(myDashPen,\n                                   (float)(XScale * j),\n                                   (float)(YOffset - YScale * (-Std[ j] + Mean[ j])),\n                                   (float)(XScale * (j + 1)), (float)(YOffset - YScale * (-Std[j + 1] + Mean[ j + 1])));\n\n            }\n            mut.ReleaseMutex();\n        }\n\n\n        public HistogramWithStim GetInterSpikeHistogram(int channel, int unitID)\n        {\n            foreach (BoxUnitWithStim unit in lstChannelUnits[channel])\n            {\n                if (unit.GetUnitID() == unitID)\n                {\n                    return unit.GetInterSpikeHistogram();\n                }\n            }\n            return new HistogramWithStim(0,0,0);\n        }\n\n        public bool QueryNewData(int channel, int unitID)\n        {\n            foreach (BoxUnitWithStim unit in lstChannelUnits[channel])\n            {\n                if (unit.GetUnitID() == unitID)\n                {\n                    return unit.QueryNewData();\n                }\n            }\n            return false;\n        }\n\n        public void ClearBuffer(int ch)\n        {\n            WaveFormBuffer[ch].Clear();\n        }\n\n        public WaveForm GetLastWaveForm(int channel)\n        {\n            mut.WaitOne();\n            WaveForm wf ;\n            if (WaveFormBuffer[channel].Count > 0)\n                wf = WaveFormBuffer[channel][WaveFormBuffer[channel].Count - 1];\n            else\n                wf = new WaveForm();\n\n            mut.ReleaseMutex();\n            return wf;\n        }\n\n\t\t*/\n\n/**************************/\n\ncPolygonWithStim::cPolygonWithStim()\n{\n};\n\nbool cPolygonWithStim::isPointInside(PointDWithStim p)\n{\n    PointDWithStim p1, p2;\n\n    bool inside = false;\n\n    if (pts.size() < 3)\n    {\n        return inside;\n    }\n\n    PointDWithStim oldPoint(pts[pts.size()- 1].X + offset.X, pts[pts.size()- 1].Y + offset.Y);\n\n    for (int i = 0; i < pts.size(); i++)\n    {\n        PointDWithStim newPoint(pts[i].X + offset.X, pts[i].Y + offset.Y);\n\n        if (newPoint.X > oldPoint.X)\n        {\n            p1 = oldPoint;\n            p2 = newPoint;\n        }\n        else\n        {\n            p1 = newPoint;\n            p2 = oldPoint;\n        }\n\n        if ((newPoint.X < p.X) == (p.X <= oldPoint.X)\n            && ((p.Y - p1.Y) * (p2.X - p1.X)\t< (p2.Y - p1.Y) * (p.X - p1.X)))\n        {\n            inside = !inside;\n        }\n\n        oldPoint = newPoint;\n    }\n\n    return inside;\n}\n\n\n\n\n\n\n\n\n\n/*****************/\n\n\n/*************************/\nPCAUnitWithStim::PCAUnitWithStim()\n{\n\n}\n\nPCAUnitWithStim::PCAUnitWithStim(int ID, int localID_): UnitID(ID),localID(localID_)\n{\n    BoxUnitWithStim::setDefaultColors(ColorRGB, localID);\n};\n\nPCAUnitWithStim::~PCAUnitWithStim()\n{\n}\n\nPCAUnitWithStim::PCAUnitWithStim(cPolygonWithStim B, int ID, int localID_) : UnitID(ID), localID(localID_)\n{\n    poly = B;\n}\n\nint PCAUnitWithStim::getUnitID()\n{\n    return UnitID;\n}\nint PCAUnitWithStim::getLocalID()\n{\n    return localID;\n}\n\nbool PCAUnitWithStim::isPointInsidePolygon(PointDWithStim p)\n{\n    return poly.isPointInside(p);\n}\n\nbool PCAUnitWithStim::isWaveFormInsidePolygon(SorterSpikeWithStimPtr so)\n{\n    return poly.isPointInside(PointDWithStim(so->pcProj[0],so->pcProj[1]));\n}\n\nvoid PCAUnitWithStim::resizeWaveform(int newlength)\n{\n}\n\n\nvoid PCAUnitWithStim::updateWaveform(SorterSpikeWithStimPtr so)\n{\n    WaveformStat.update(so);\n}\n\n/***************************/\n\n\n/*\n  An implementation of SVD from Numerical Recipes in C and Mike Erhdmann's lectures\n*/\n\n\n#define SIGN(a,b) ((b) > 0.0 ? fabs(a) : - fabs(a))\n\nstatic double maxarg1,maxarg2;\n#define FMAX(a,b) (maxarg1 = (a),maxarg2 = (b),(maxarg1) > (maxarg2) ? (maxarg1) : (maxarg2))\n\nstatic int iminarg1,iminarg2;\n#define IMIN(a,b) (iminarg1 = (a),iminarg2 = (b),(iminarg1 < (iminarg2) ? (iminarg1) : iminarg2))\n\nstatic double sqrarg;\n#define SQR(a) ((sqrarg = (a)) == 0.0 ? 0.0 : sqrarg * sqrarg)\n\nPCAjobWithStim::PCAjobWithStim(SorterSpikeWithStimArray& _spikes, float* _pc1, float* _pc2,\n                std::atomic<float>& pc1Min,  std::atomic<float>& pc2Min,  std::atomic<float>&pc1Max,  std::atomic<float>& pc2Max, std::atomic<bool>& _reportDone) : spikes(_spikes),\npc1min(pc1Min), pc2min(pc2Min), pc1max(pc1Max), pc2max(pc2Max), reportDone(_reportDone)\n{\n\tSorterSpikeWithStimPtr spike = spikes[0];\n    cov = nullptr;\n    pc1 = _pc1;\n    pc2 = _pc2;\n\n    dim = spike->getChannel()->getNumChannels()*spike->getChannel()->getTotalSamples();\n\n};\n\nPCAjobWithStim::~PCAjobWithStim()\n{\n\n}\n\n\n\n// calculates sqrt( a^2 + b^2 ) with decent precision\nfloat PCAjobWithStim::pythag(float a, float b)\n{\n    float absa,absb;\n\n    absa = fabs(a);\n    absb = fabs(b);\n\n    if (absa > absb)\n        return (absa * sqrt(1.0 + SQR(absb/absa)));\n    else\n        return (absb == 0.0 ? 0.0 : absb * sqrt(1.0 + SQR(absa / absb)));\n}\n\n/*\n  Modified from Numerical Recipes in C\n  Given a matrix a[nRows][nCols], svdcmp() computes its singular value\n  decomposition, A = U * W * Vt.  A is replaced by U when svdcmp\n  returns.  The diagonal matrix W is output as a vector w[nCols].\n  V (not V transpose) is output as the matrix V[nCols][nCols].\n*/\nint PCAjobWithStim::svdcmp(float** a, int nRows, int nCols, float* w, float** v)\n{\n\n    int flag, i, its, j, jj, k, l = 0, nm = 0;\n    float anorm, c, f, g, h, s, scale, x, y, z, *rv1;\n\n    rv1 = new float[nCols];\n    if (rv1 == NULL)\n    {\n        printf(\"svdcmp(): Unable to allocate vector\\n\");\n        return (-1);\n    }\n\n    g = scale = anorm = 0.0;\n    for (i = 0; i < nCols; i++)\n    {\n        l = i+1;\n        rv1[i] = scale*g;\n        g = s = scale = 0.0;\n        if (i < nRows)\n        {\n            for (k = i; k < nRows; k++)\n            {\n                //std::cout << k << \" \" << i << std::endl;\n                scale += fabs(a[k][i]);\n            }\n\n            if (scale)\n            {\n                for (k = i; k < nRows; k++)\n                {\n                    a[k][i] /= scale;\n                    s += a[k][i] * a[k][i];\n                }\n                f = a[i][i];\n                g = -SIGN(sqrt(s),f);\n                h = f * g - s;\n                a[i][i] = f - g;\n\n                for (j = l; j < nCols; j++)\n                {\n                    for (s = 0.0, k = i; k < nRows; k++) s += a[k][i] * a[k][j];\n                    f = s / h;\n                    for (k = i; k < nRows; k++) a[k][j] += f * a[k][i];\n                }\n\n                for (k = i; k < nRows; k++)\n                    a[k][i] *= scale;\n            } // end if (scale)\n        } // end if (i < nRows)\n        w[i] = scale * g;\n        g = s = scale = 0.0;\n        if (i < nRows && i != nCols-1)\n        {\n            for (k = l; k < nCols; k++) scale += fabs(a[i][k]);\n            if (scale)\n            {\n                for (k = l; k < nCols; k++)\n                {\n                    a[i][k] /= scale;\n                    s += a[i][k] * a[i][k];\n                }\n                f = a[i][l];\n                g = - SIGN(sqrt(s),f);\n                h = f * g - s;\n                a[i][l] = f - g;\n                for (k=l; k<nCols; k++) rv1[k] = a[i][k] / h;\n                for (j=l; j<nRows; j++)\n                {\n                    for (s=0.0,k=l; k<nCols; k++) s += a[j][k] * a[i][k];\n                    for (k=l; k<nCols; k++) a[j][k] += s * rv1[k];\n                }\n                for (k=l; k<nCols; k++) a[i][k] *= scale;\n            }\n        }\n        anorm = FMAX(anorm, (fabs(w[i]) + fabs(rv1[i])));\n\n\n    }\n\n    for (i=nCols-1; i>=0; i--)\n    {\n        if (i < nCols-1)\n        {\n            if (g)\n            {\n                for (j=l; j<nCols; j++)\n                    v[j][i] = (a[i][j] / a[i][l]) / g;\n                for (j=l; j<nCols; j++)\n                {\n                    for (s=0.0,k=l; k<nCols; k++) s += a[i][k] * v[k][j];\n                    for (k=l; k<nCols; k++) v[k][j] += s * v[k][i];\n                }\n            }\n            for (j=l; j<nCols; j++) v[i][j] = v[j][i] = 0.0;\n        }\n        v[i][i] = 1.0;\n        g = rv1[i];\n        l = i;\n    }\n\n    for (i=IMIN(nRows,nCols) - 1; i >= 0; i--)\n    {\n        l = i + 1;\n        g = w[i];\n        for (j=l; j<nCols; j++) a[i][j] = 0.0;\n        if (g)\n        {\n            g = 1.0 / g;\n            for (j=l; j<nCols; j++)\n            {\n                for (s=0.0,k=l; k<nRows; k++) s += a[k][i] * a[k][j];\n                f = (s / a[i][i]) * g;\n                for (k=i; k<nRows; k++) a[k][j] += f * a[k][i];\n            }\n            for (j=i; j<nRows; j++) a[j][i] *= g;\n        }\n        else\n            for (j=i; j<nRows; j++) a[j][i] = 0.0;\n        ++a[i][i];\n    }\n\n    for (k=nCols-1; k>=0; k--)\n    {\n        for (its=0; its<30; its++)\n        {\n            flag = 1;\n            for (l=k; l>=0; l--)\n            {\n                nm = l-1;\n                if ((fabs(rv1[l]) + anorm) == anorm)\n                {\n                    flag =  0;\n                    break;\n                }\n                if ((fabs(w[nm]) + anorm) == anorm) break;\n            }\n            if (flag)\n            {\n                c = 0.0;\n                s = 1.0;\n                for (i=l; i<=k; i++)\n                {\n                    f = s * rv1[i];\n                    rv1[i] = c * rv1[i];\n                    if ((fabs(f) + anorm) == anorm) break;\n                    g = w[i];\n                    h = pythag(f,g);\n                    w[i] = h;\n                    h = 1.0 / h;\n                    c = g * h;\n                    s = -f * h;\n                    for (j=0; j<nRows; j++)\n                    {\n                        y = a[j][nm];\n                        z = a[j][i];\n                        a[j][nm] = y * c + z * s;\n                        a[j][i] = z * c - y * s;\n                    }\n                }\n            }\n            z = w[k];\n            if (l == k)\n            {\n                if (z < 0.0)\n                {\n                    w[k] = -z;\n                    for (j=0; j<nCols; j++) v[j][k] = -v[j][k];\n                }\n                break;\n            }\n            //if(its == 29) printf(\"no convergence in 30 svdcmp iterations\\n\");\n            x = w[l];\n            nm = k-1;\n            y = w[nm];\n            g = rv1[nm];\n            h = rv1[k];\n            f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);\n            g = pythag(f,1.0);\n            f = ((x - z) * (x + z) + h * ((y / (f + SIGN(g,f))) - h)) / x;\n            c = s = 1.0;\n            for (j=l; j<=nm; j++)\n            {\n                i = j+1;\n                g = rv1[i];\n                y = w[i];\n                h = s * g;\n                g = c * g;\n                z = pythag(f,h);\n                rv1[j] = z;\n                c = f/z;\n                s = h/z;\n                f = x * c + g * s;\n                g = g * c - x * s;\n                h = y * s;\n                y *= c;\n                for (jj=0; jj<nCols; jj++)\n                {\n                    x = v[jj][j];\n                    z = v[jj][i];\n                    v[jj][j] = x * c + z * s;\n                    v[jj][i] = z * c - x * s;\n                }\n                z = pythag(f,h);\n                w[j] = z;\n                if (z)\n                {\n                    z = 1.0 / z;\n                    c = f * z;\n                    s = h * z;\n                }\n                f = c * g + s * y;\n                x = c * y - s * g;\n                for (jj=0; jj < nRows; jj++)\n                {\n                    y = a[jj][j];\n                    z = a[jj][i];\n                    a[jj][j] = y * c + z * s;\n                    a[jj][i] = z * c - y * s;\n                }\n            }\n            rv1[l] = 0.0;\n            rv1[k] = f;\n            w[k] = x;\n        }\n    }\n\n    delete[] rv1;\n\n    return (0);\n}\n\n\nvoid PCAjobWithStim::computeCov()\n{\n    // allocate and zero\n    cov = new float*[dim];\n    float* mean  = new float[dim];\n    for (int k = 0; k < dim; k++)\n    {\n        cov[k] = new float[dim];\n        for (int j=0; j<dim; j++)\n        {\n            cov[k][j] = 0;\n        }\n    }\n    // compute mean\n\n    for (int j=0; j<dim; j++)\n    {\n        mean[j] = 0;\n        for (int i=0; i<spikes.size(); i++)\n        {\n            SorterSpikeWithStimPtr spike = spikes[i];\n            float v = spikeDataIndexToMicrovolts(spike, j) ;\n            mean[j] += v / dim;\n        }\n    }\n    // aggregate\n\n\n    for (int i=0; i<dim; i++)\n    {\n        for (int j=i; j<dim; j++)\n        {\n            // cov[i][j] = sum_k[ (X(i,:)) * (Xj-mue(j) ]\n            float sum = 0 ;\n            for (int k=0; k<spikes.size(); k++)\n            {\n\n                SorterSpikeWithStimPtr spike = spikes[k];\n                float vi = spikeDataIndexToMicrovolts(spike, i);\n                float vj = spikeDataIndexToMicrovolts(spike, j);\n                sum += (vi-mean[i]) * (vj-mean[j]);\n            }\n            cov[i][j] = sum / (dim-1);\n            cov[j][i] = sum / (dim-1);\n        }\n    }\n    delete[] mean;\n\n    // delete covariances\n    //for (int k = 0; k < dim; k++)\n    //delete cov[k];\n\n    //delete(cov);\n    //cov = nullptr;\n\n}\n\nstd::vector<int> sort_indexes(std::vector<float> v)\n{\n    // initialize original index locations\n    std::vector<int> idx(v.size());\n\n    for (int i = 0; i != idx.size(); ++i)\n    {\n        idx[i] = i;\n    }\n\n    //sort indexes based on comparing values in v\n    sort(\n        idx.begin(),\n        idx.end()//,\n        //[&v](size_t i1, size_t i2)\n        //{\n        //\treturn v[i1] > v[i2];\n        //}\n    );\n\n    return idx;\n}\n\nvoid PCAjobWithStim::computeSVD()\n{\n\n\n    float** eigvec, *sigvalues;\n    sigvalues = new float[dim];\n\n    eigvec = new float*[dim];\n    for (int k = 0; k < dim; k++)\n    {\n        eigvec[k] = new float[dim];\n        for (int j=0; j<dim; j++)\n        {\n            eigvec[k][j] = 0;\n        }\n    }\n\n    svdcmp(cov, dim, dim, sigvalues, eigvec);\n\n    std::vector<float> sig;\n    sig.resize(dim);\n    for (int k = 0; k < dim; k++)\n        sig[k] = sigvalues[k];\n\n    std::vector<int> sortind = sort_indexes(sig);\n\n    for (int k = 0; k < dim; k++)\n    {\n        pc1[k] = eigvec[k][sortind[0]];\n        pc2[k] = eigvec[k][sortind[1]];\n    }\n    // project samples to find the display range\n    float min1 = 1e10, min2 = 1e10, max1 = -1e10, max2 = -1e10;\n\n    for (int j = 0; j < spikes.size(); j++)\n    {\n        float sum1 = 0, sum2=0;\n        for (int k = 0; k < dim; k++)\n        {\n            SorterSpikeWithStimPtr spike = spikes[j];\n            sum1 += spikeDataIndexToMicrovolts(spike,k) * pc1[k];\n            sum2 += spikeDataIndexToMicrovolts(spike,k) * pc2[k];\n        }\n        if (sum1 < min1)\n            min1 = sum1;\n        if (sum2 < min2)\n            min2 = sum2;\n        if (sum1 > max1)\n            max1 = sum1;\n        if (sum2 > max2)\n            max2 = sum2;\n    }\n\n\n    pc1min = min1 - 1.5 * (max1-min1);\n    pc2min = min2 - 1.5 * (max2-min2);\n    pc1max = max1 + 1.5 * (max1-min1);\n    pc2max = max2 + 1.5 * (max2-min2);\n\n    // clear memory\n    for (int k = 0; k < dim; k++)\n    {\n        delete[] eigvec[k];\n    }\n    delete[] eigvec;\n    delete[] sigvalues;\n\n    // delete covariances\n    for (int k = 0; k < dim; k++)\n        delete[] cov[k];\n\n    delete[] cov;\n    cov = nullptr;\n\n}\n\n\n/**********************/\n\n\nvoid PCAcomputingThreadWithStim::addPCAjob(PCAJobWithStimPtr job)\n{\n\t{\n\t\tScopedLock critical(lock);\n\t\tjobs.add(job);\n\t}\n\t\n    if (!isThreadRunning())\n    {\n        startThread();\n    }\n}\n\nvoid PCAcomputingThreadWithStim::run()\n{\n    while (jobs.size() > 0)\n    {\n\t\tlock.enter();\n        PCAJobWithStimPtr J = jobs.removeAndReturn(0);\n\tif (J == nullptr) continue;\n\t\tlock.exit();\n        // compute PCA\n        // 1. Compute Covariance matrix\n        // 2. Apply SVD on covariance matrix\n        // 3. Extract the two principal components corresponding to the largest singular values\n\n        J->computeCov();\n        J->computeSVD();\n\n        // 4. Report to the spike sorting electrode that PCA is finished\n        J->reportDone = true;\n    }\n}\n\n\nPCAcomputingThreadWithStim::PCAcomputingThreadWithStim() : Thread(\"PCA\")\n{\n\n}\n\n\n/**************************/\n\nfloat spikeDataBinToMicrovolts(SorterSpikeWithStimPtr s, int bin, int ch)\n{\n\tjassert(ch >= 0 && ch < s->getChannel()->getNumChannels());\n\tjassert(bin >= 0 && bin <= s->getChannel()->getTotalSamples());\n\tfloat v = s->getData()[bin + ch*s->getChannel()->getTotalSamples()];\n\treturn v;\n}\n\n\nfloat spikeDataIndexToMicrovolts(SorterSpikeWithStimPtr s, int index)\n{\n\tfloat v = s->getData()[index];\n\treturn v;\n}\n\nfloat spikeTimeBinToMicrosecond(SorterSpikeWithStimPtr s, int bin, int ch)\n{\n\tfloat spikeTimeSpan = 1.0f / s->getChannel()->getSampleRate() * s->getChannel()->getTotalSamples() * 1e6;\n\treturn float(bin) / (s->getChannel()->getTotalSamples() - 1) * spikeTimeSpan;\n}\n\nint microSecondsToSpikeTimeBin(SorterSpikeWithStimPtr s, float t, int ch)\n{\n\t// Lets say we have 32 samples per wave form\n\n\t// t = 0 corresponds to the left most index.\n\tfloat spikeTimeSpan = (1.0f / s->getChannel()->getSampleRate() * s->getChannel()->getTotalSamples())*1e6;\n\treturn MIN(s->getChannel()->getTotalSamples() - 1, MAX(0, t / spikeTimeSpan * (s->getChannel()->getTotalSamples() - 1)));\n}\n\n\nSorterSpikeContainerWithStim::SorterSpikeContainerWithStim(const SpikeChannel* channel, SpikeEvent::SpikeBuffer& spikedata, int64 timestamp)\n{\n\tcolor[0] = color[1] = color[2] = 127;\n\tpcProj[0] = pcProj[1] = 0;\n\tsortedId = 0;\n\tthis->timestamp = timestamp;\n\tchan = channel;\n\tint nSamples = chan->getNumChannels() * chan->getTotalSamples();\n\tdata.malloc(nSamples);\n\tmemcpy(data.getData(), spikedata.getRawPointer(), nSamples*sizeof(float));\n}\n\nconst float* SorterSpikeContainerWithStim::getData() const\n{\n\treturn data.getData();\n}\n\nconst SpikeChannel* SorterSpikeContainerWithStim::getChannel() const\n{\n\treturn chan;\n}\n\nint64 SorterSpikeContainerWithStim::getTimestamp() const\n{\n\treturn timestamp;\n}\n",
			"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSortBoxesWithStim.cpp",
			"file_size": 61698,
			"file_write_time": 132277941511824576,
			"settings":
			{
				"buffer_size": 61691,
				"encoding": "UTF-8 with BOM",
				"line_ending": "Unix"
			}
		},
		{
			"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSorterWithStim.cpp",
			"settings":
			{
				"buffer_size": 60042,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/*\n    ------------------------------------------------------------------\n\n    This file is part of the Open Ephys GUI\n    Copyright (C) 2013 Open Ephys\n\n    ------------------------------------------------------------------\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n#include \"SpikeSorterEditorWithStim.h\"\n#include \"SpikeSorterCanvasWithStim.h\"\n#include \"SpikeSorterWithStim.h\"\n#include \"../OnlineDecoding/SleepScorer/SleepScorerFilter.h\"\n#include \"../OnlineDecoding/SleepScorer/SleepScorerProcessor.h\"\n\n#include <stdio.h>\n\n\n\nSpikeSorterEditorWithStim::SpikeSorterEditorWithStim(GenericProcessor* parentNode, bool useDefaultParameterEditors=true)\n    : VisualizerEditor(parentNode, 300, useDefaultParameterEditors), spikeSorterCanvas(nullptr), isPlural(true)\n\n{\n    tabText = \"Spike Detector With Stim\";\n\n\tint silksize;\n\tconst char* silk = CoreServices::getApplicationResource(\"silkscreenserialized\", silksize);\n    MemoryInputStream mis(silk, silksize, false);\n    Typeface::Ptr typeface = new CustomTypeface(mis);\n    font = Font(typeface);\n\n    desiredWidth = 300;\n\n    //SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n    sleepStateList = new ComboBox(\"Sleep states list\");\n    sleepStateList->addListener(this);\n    sleepStateList->addItem(\"Any\", SleepState::undefinedSleepState);\n    sleepStateList->addItem(SleepScorerProcessor::sleepStateAsText(SleepState::Wake), SleepState::Wake);\n    sleepStateList->addItem(SleepScorerProcessor::sleepStateAsText(SleepState::REM), SleepState::REM);\n    sleepStateList->addItem(SleepScorerProcessor::sleepStateAsText(SleepState::NREM), SleepState::NREM);\n    sleepStateList->setSelectedId(SleepState::undefinedSleepState);\n    sleepStateList->addListener(this);\n    sleepStateList->setBounds(200,105,90,20);\n    addAndMakeVisible(sleepStateList);\n\n    advancerList = new ComboBox(\"Advancers\");\n    advancerList->addListener(this);\n    advancerList->setBounds(10,95,130,20);\n    addAndMakeVisible(advancerList);\n\n    depthOffsetLabel = new Label(\"Depth Offset\",\"Depth Offset\");\n    depthOffsetLabel->setFont(Font(\"Default\", 10, Font::plain));\n    depthOffsetLabel->setEditable(false);\n    depthOffsetLabel->setBounds(125,115,80,20);\n    depthOffsetLabel->setColour(Label::textColourId, Colours::grey);\n    addAndMakeVisible(depthOffsetLabel);\n\n    advancerLabel = new Label(\"Depth Offset\",\"ADVANCER:\");\n    advancerLabel->setFont(Font(\"Default\", 10, Font::plain));\n    advancerLabel->setEditable(false);\n    advancerLabel->setBounds(10,80,80,20);\n    advancerLabel->setColour(Label::textColourId, Colours::grey);\n    addAndMakeVisible(advancerLabel);\n\n    depthOffsetEdit = new Label(\"Depth Offset\",\"0.0\");\n    depthOffsetEdit->setFont(Font(\"Default\", 10, Font::plain));\n    depthOffsetEdit->setEditable(true);\n    depthOffsetEdit->setBounds(145,95,40,20);\n    depthOffsetEdit->addListener(this);\n    depthOffsetEdit->setColour(Label::textColourId, Colours::white);\n    depthOffsetEdit->setColour(Label::backgroundColourId, Colours::grey);\n\n    addAndMakeVisible(depthOffsetEdit);\n\n    electrodeList = new ComboBox(\"ElectrodeWithStim List\");\n    electrodeList->setEditableText(false);\n    electrodeList->setJustificationType(Justification::centredLeft);\n    electrodeList->addListener(this);\n    //electrodeList->setBounds(65,30,130,20);\n    electrodeList->setBounds(65,30,100,20);\n    addAndMakeVisible(electrodeList);\n\n    numElectrodes = new Label(\"Number of Electrodes\",\"1\");\n    numElectrodes->setEditable(true);\n    numElectrodes->addListener(this);\n    numElectrodes->setBounds(30,30,25,20);\n    addAndMakeVisible(numElectrodes);\n\n    upButton = new TriangleButton(1);\n    upButton->addListener(this);\n    upButton->setBounds(50,30,10,8);\n    addAndMakeVisible(upButton);\n\n    downButton = new TriangleButton(2);\n    downButton->addListener(this);\n    downButton->setBounds(50,40,10,8);\n    addAndMakeVisible(downButton);\n\n    plusButton = new UtilityButton(\"+\", titleFont);\n    plusButton->addListener(this);\n    plusButton->setRadius(3.0f);\n    plusButton->setBounds(15,27,14,14);\n    addAndMakeVisible(plusButton);\n\n    audioMonitorButton = new UtilityButton(\"MONITOR\", Font(\"Default\", 12, Font::plain));\n    audioMonitorButton->addListener(this);\n    audioMonitorButton->setRadius(3.0f);\n    audioMonitorButton->setBounds(80,65,65,15);\n    audioMonitorButton->setClickingTogglesState(true);\n    addAndMakeVisible(audioMonitorButton);\n\n    removeElectrodeButton = new UtilityButton(\"-\",font);\n    removeElectrodeButton->addListener(this);\n    removeElectrodeButton->setBounds(15,45,14,14);\n    addAndMakeVisible(removeElectrodeButton);\n\n\n    configButton = new UtilityButton(\"CONFIG\",Font(\"Default\", 12, Font::plain));\n    configButton->addListener(this);\n    configButton->setBounds(10,65,60,15);\n    addAndMakeVisible(configButton);\n\n    thresholdSlider = new ThresholdSlider(font);\n    thresholdSlider->setBounds(210,25,65,65);\n    addAndMakeVisible(thresholdSlider);\n    thresholdSlider->addListener(this);\n    thresholdSlider->setActive(false);\n    Array<double> v;\n    thresholdSlider->setValues(v);\n\n    thresholdLabel = new Label(\"Name\",\"Threshold\");\n    font.setHeight(10);\n    thresholdLabel->setFont(font);\n    thresholdLabel->setBounds(208, 85, 95, 15);\n    thresholdLabel->setColour(Label::textColourId, Colours::grey);\n    addAndMakeVisible(thresholdLabel);\n\n    // create a custom channel selector\n    deleteAndZero(channelSelector);\n\n    channelSelector = new ChannelSelector(true, font);\n    addChildComponent(channelSelector);\n    channelSelector->setVisible(false);\n\n    channelSelector->activateButtons();\n    channelSelector->setRadioStatus(true);\n    channelSelector->paramButtonsToggledByDefault(false);\n    //\tupdateAdvancerList();\n\n /*   dacAssignmentLabel= new Label(\"DAC output\",\"DAC output\");\n    dacAssignmentLabel->setFont(Font(\"Default\", 10, Font::plain));\n    dacAssignmentLabel->setEditable(false);\n    dacAssignmentLabel->setBounds(210,115,80,20);\n    dacAssignmentLabel->setColour(Label::textColourId, Colours::grey);\n    addAndMakeVisible(dacAssignmentLabel);\n\n    dacCombo = new ComboBox(\"DAC Assignment\");\n    dacCombo->addListener(this);\n    dacCombo->setBounds(205,100,70,18);\n    dacCombo->addItem(\"-\",1);\n    for (int k=0; k<8; k++)\n    {\n        dacCombo->addItem(\"DAC\"+String(k+1),k+2);\n    }\n    dacCombo->setSelectedId(1);\n    addAndMakeVisible(dacCombo);*/\n\n}\n\nVisualizer* SpikeSorterEditorWithStim::createNewCanvas()\n{\n\n    SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n    spikeSorterCanvas = new SpikeSorterCanvasWithStim(processor);\n    //ActionListener* listener = (ActionListener*) SpikeSorterCanvasWithStim;\n    //getUIComponent()->registerAnimatedComponent(listener);\n    return spikeSorterCanvas;\n}\n\n\nSpikeSorterEditorWithStim::~SpikeSorterEditorWithStim()\n{\n\n    for (int i = 0; i < electrodeButtons.size(); i++)\n    {\n        removeChildComponent(electrodeButtons[i]);\n    }\n\n}\n\nvoid SpikeSorterEditorWithStim::sliderEvent(Slider* slider)\n{\n    int electrodeNum = -1;\n\n    for (int i = 0; i < electrodeButtons.size(); i++)\n    {\n        if (electrodeButtons[i]->getToggleState())\n        {\n            electrodeNum = i;\n            break;\n        }\n    }\n\n    if (electrodeNum > -1)\n    {\n        // new\n        SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n        if (processor->getEditAllState()){\n            int numElectrodes = processor->getNumElectrodes();\n            for (int electrodeIt = 0 ; electrodeIt < numElectrodes ; electrodeIt++){\n                //processor->setChannelThreshold(electrodeList->getSelectedItemIndex(),i,slider->getValue());\n                for (int channelIt = 0 ; channelIt < processor->getNumChannels(electrodeIt) ; channelIt++){\n                    processor->setChannelThreshold(electrodeIt,channelIt,slider->getValue());\n                }\n            }\n        }\n        else{\n        processor->setChannelThreshold(electrodeList->getSelectedItemIndex(),\n                                       electrodeNum,\n                                       slider->getValue());\n        }\n\n\n     /*   //Array<int> dacChannels = processor->getDACassignments;\n        int dacChannel = dacCombo->getSelectedId()-2;\n        if (dacChannel >= 0)\n        {\n            // update dac threshold.\n            processor->updateDACthreshold(dacChannel, slider->getValue());\n        }*/\n\n    }\n    repaint();\n    if (canvas!= nullptr)\n        canvas->repaint();\n\n}\n\n\nvoid SpikeSorterEditorWithStim::buttonEvent(Button* button)\n{\n \n    SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n    \n    if (electrodeButtons.contains((ElectrodeButton*) button))\n    {\n\n        {\n            for (int k=0; k<electrodeButtons.size(); k++)\n            {\n                if (electrodeButtons[k] != button)\n                    electrodeButtons[k]->setToggleState(false,dontSendNotification);\n            }\n            if (electrodeButtons.size() == 1)\n                electrodeButtons[0]->setToggleState(true,dontSendNotification);\n\n            ElectrodeButton* eb = (ElectrodeButton*) button;\n            int channelNum = eb->getChannelNum()-1;\n\n            std::cout << \"Channel number: \" << channelNum << std::endl;\n            Array<int> a;\n            a.add(channelNum);\n            channelSelector->setActiveChannels(a);\n\n            SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n\n            thresholdSlider->setActive(true);\n            thresholdSlider->setValue(processor->getChannelThreshold(electrodeList->getSelectedItemIndex(),\n                                                                     electrodeButtons.indexOf((ElectrodeButton*) button)));\n\n\n        /*    if (processor->getAutoDacAssignmentStatus())\n            {\n                processor->assignDACtoChannel(0, channelNum);\n                processor->assignDACtoChannel(1, channelNum);\n            }\n            Array<int> dacAssignmentToChannels = processor->getDACassignments();\n            // search for channel[0]. If found, set the combo box accordingly...\n            dacCombo->setSelectedId(1, sendNotification);\n            for (int i=0; i<dacAssignmentToChannels.size(); i++)\n            {\n                if (dacAssignmentToChannels[i] == channelNum)\n                {\n                    dacCombo->setSelectedId(i+2, sendNotification);\n                    break;\n                }\n            }*/\n\n        }\n    }\n\n\n    int num = numElectrodes->getText().getIntValue();\n\n    if (button == upButton)\n    {\n        numElectrodes->setText(String(++num), sendNotification);\n\n        return;\n\n    }\n    else if (button == downButton)\n    {\n\n        if (num > 1)\n            numElectrodes->setText(String(--num), sendNotification);\n\n        return;\n\n    }\n    else if (button == configButton)\n    {\n        PopupMenu configMenu;\n        PopupMenu waveSizeMenu;\n        PopupMenu waveSizePreMenu;\n        PopupMenu waveSizePostMenu;\n\t\tbool allowSampleChange = !CoreServices::getAcquisitionStatus();\n\n        waveSizePreMenu.addItem(1,\"8\",allowSampleChange,processor->getNumPreSamples() == 8);\n\t\twaveSizePreMenu.addItem(2, \"16\", allowSampleChange, processor->getNumPreSamples() == 16);\n\t\twaveSizePostMenu.addItem(3, \"32\", allowSampleChange, processor->getNumPostSamples() == 32);\n\t\twaveSizePostMenu.addItem(4, \"64\", allowSampleChange, processor->getNumPostSamples() == 64);\n\n        waveSizeMenu.addSubMenu(\"Pre samples\",waveSizePreMenu);\n        waveSizeMenu.addSubMenu(\"Post samples\",waveSizePostMenu);\n        waveSizeMenu.addItem(7,\"Flip Signal\",true,processor->getFlipSignalState());\n        configMenu.addSubMenu(\"Waveform\",waveSizeMenu,true);\n        configMenu.addItem(5,\"Current Channel => Audio\",true,processor->getAutoDacAssignmentStatus());\n        configMenu.addItem(6,\"Threshold => All channels\",true,processor->getThresholdSyncStatus());\n\n        const int result = configMenu.show();\n        switch (result)\n        {\n            case 1:\n                processor->setNumPreSamples(8);\n\t\t\t\tCoreServices::updateSignalChain(this);\n                break;\n            case 2:\n                processor->setNumPreSamples(16);\n\t\t\t\tCoreServices::updateSignalChain(this);\n                break;\n            case 3:\n                processor->setNumPostSamples(32);\n\t\t\t\tCoreServices::updateSignalChain(this);\n                break;\n            case 4:\n                processor->setNumPostSamples(64);\n\t\t\t\tCoreServices::updateSignalChain(this);\n                break;\n            case 5:\n                processor->seteAutoDacAssignment(!processor->getAutoDacAssignmentStatus());\n                refreshElectrodeList();\n                break;\n            case 6:\n                processor->setThresholdSyncStatus(!processor->getThresholdSyncStatus());\n                break;\n            case 7:\n                processor->setFlipSignalState(!processor->getFlipSignalState());\n                break;\n        }\n\n    }\n    else if (button == plusButton)\n    {\n        // std::cout << \"Plus button pressed!\" << std::endl;\n        if (acquisitionIsActive)\n        {\n            CoreServices::sendStatusMessage(\"Stop acquisition before adding electrodes.\");\n            return;\n        }\n\n        //updateAdvancerList();\n        PopupMenu probeMenu;\n        probeMenu.addItem(1,\"Single ElectrodeWithStim\");\n        probeMenu.addItem(-1,\"Single ElectrodeWithoutStim\");\n        probeMenu.addItem(2,\"Stereotrode\");\n        probeMenu.addItem(3,\"Tetrode\");\n        PopupMenu depthprobeMenu;\n        depthprobeMenu.addItem(4,\"8 ch, 125um\");\n        depthprobeMenu.addItem(5,\"16 ch, 125um\");\n        depthprobeMenu.addItem(6,\"24 ch, 125um\");\n        depthprobeMenu.addItem(7,\"32 ch, 50um\");\n        depthprobeMenu.addItem(8,\"32 ch, 25um\");\n        probeMenu.addSubMenu(\"Depth probe\", depthprobeMenu,true);\n\n        const int result = probeMenu.show();\n        int nChansPerElectrode = 0;\n        int nElectrodes = 0;\n        double interelectrodeDistance = 0;\n        double firstElectrodeOffset = 0;\n        int numProbes = numElectrodes->getText().getIntValue();\n        String ProbeType;\n\n        switch (result)\n        {\n            case 0:\n                return;\n            case 1:\n                ProbeType = \"Single ElectrodeWithStim\";\n                nChansPerElectrode = 1;\n                nElectrodes = 1;\n                firstElectrodeOffset=0;\n                break;\n            case -1:\n                ProbeType = \"Single ElectrodeWithoutStim\";\n                nChansPerElectrode = -1;\n                nElectrodes = 1;\n                firstElectrodeOffset=0;\n                break;\n            case 2:\n                ProbeType = \"Stereotrode\";\n                nChansPerElectrode = 2;\n                nElectrodes = 1;\n                firstElectrodeOffset = 0;\n                break;\n            case 3:\n                ProbeType = \"Tetrode\";\n                nChansPerElectrode = 4;\n                nElectrodes = 1;\n                firstElectrodeOffset = 0;\n                break;\n            case 4:\n                ProbeType = \"Depth Probe\";\n                nChansPerElectrode = 1;\n                nElectrodes = 8;\n                interelectrodeDistance = 0.125;\n                firstElectrodeOffset= -0.5;\n                break;\n            case 5:\n                ProbeType = \"Depth Probe\";\n                nChansPerElectrode = 1;\n                nElectrodes = 16;\n                interelectrodeDistance = 0.125;\n                firstElectrodeOffset= -0.5;\n                break;\n            case 6:\n                ProbeType = \"Depth Probe\";\n                nChansPerElectrode = 1;\n                nElectrodes = 24;\n                interelectrodeDistance = 0.125;\n                firstElectrodeOffset= -0.5;\n                break;\n            case 7:\n                ProbeType = \"Depth Probe\";\n                nChansPerElectrode = 1;\n                nElectrodes = 32;\n                interelectrodeDistance = 0.050;\n                firstElectrodeOffset= -0.5;\n                break;\n            case 8:\n                ProbeType = \"Depth Probe\";\n                nChansPerElectrode = 1;\n                nElectrodes = 32;\n                interelectrodeDistance = 0.025;\n                firstElectrodeOffset= -0.075;\n                break;\n        }\n\n        processor->addProbes(ProbeType,numProbes, nElectrodes,nChansPerElectrode, firstElectrodeOffset,interelectrodeDistance);\n        refreshElectrodeList();\n\n        CoreServices::updateSignalChain(this);\n        CoreServices::highlightEditor(this);\n\n        return;\n\n    }\n    else if (button == removeElectrodeButton)   // DELETE\n    {\n        if (acquisitionIsActive)\n        {\n            CoreServices::sendStatusMessage(\"Stop acquisition before deleting electrodes.\");\n            return;\n        }\n        removeElectrode(electrodeList->getSelectedItemIndex());\n\n        //getEditorViewport()->makeEditorVisible(this, true, true);\n\n        return;\n    }\n    else if (button == audioMonitorButton)\n    {\n\n        channelSelector->clearAudio();\n\n        SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n\n        const OwnedArray<ElectrodeWithStim>& electrodes = processor->getElectrodes();\n\t\tint nElectrodes = electrodes.size();\n\t\tif (nElectrodes <= 0)\n\t\t{\n\t\t\taudioMonitorButton->setToggleState(false, dontSendNotification);\n\t\t\treturn;\n\t\t}\n\n        for (int i = 0; i < nElectrodes; i++)\n        {\n            ElectrodeWithStim* e = electrodes[i];\n            e->isMonitored = false;\n        }\n\n        ElectrodeWithStim* e = processor->getActiveElectrode();\n        e->isMonitored = audioMonitorButton->getToggleState();\n\n        for (int i = 0; i < e->numChannels; i++)\n        {\n            int channelNum = e->channels[i];\n            channelSelector->setAudioStatus(channelNum, audioMonitorButton->getToggleState());\n\n        }\n\n    }\n\n\n\n}\n\nvoid SpikeSorterEditorWithStim::setThresholdValue(int channel, double threshold)\n{\n    thresholdSlider->setActive(true);\n    thresholdSlider->setValue(threshold);\n    repaint();\n}\n\nvoid SpikeSorterEditorWithStim::channelChanged (int channel, bool newState)\n{\n    //std::cout << \"New channel: \" << chan << std::endl;\n    if (channel <= 0)\n        return;\n\n    const int numElectrodeButtons = electrodeButtons.size();\n    for (int i = 0; i < numElectrodeButtons; ++i)\n    {\n        if (electrodeButtons[i]->getToggleState())\n        {\n            electrodeButtons[i]->setChannelNum (channel);\n            electrodeButtons[i]->repaint();\n\n            Array<int> a;\n            a.add (channel - 1);\n            channelSelector->setActiveChannels (a);\n\n            SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n            processor->setChannel(electrodeList->getSelectedItemIndex(),\n                                  i,\n                                  channel - 1);\n\n         /*   // if DAC is selected, update the mapping.\n            int dacchannel = dacCombo->getSelectedId() - 2;\n            if (dacchannel >=0)\n            {\n                processor->assignDACtoChannel (dacchannel, channel - 1);\n            }\n            if (processor->getAutoDacAssignmentStatus())\n            {\n                processor->assignDACtoChannel (0, channel - 1);\n                processor->assignDACtoChannel (1, channel - 1);\n                break;\n            }*/\n        }\n    }\n}\n\nint SpikeSorterEditorWithStim::getSelectedElectrode()\n{\n    return electrodeList->getSelectedId();\n}\n\nvoid SpikeSorterEditorWithStim::setSelectedElectrode(int i)\n{\n    electrodeList->setSelectedId(i);\n}\n\nvoid SpikeSorterEditorWithStim::refreshElectrodeList(int selected)\n{\n    electrodeList->clear();\n\n    SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n\n    StringArray electrodeNames = processor->getElectrodeNames();\n\n    for (int i = 0; i < electrodeNames.size(); i++)\n    {\n        electrodeList->addItem(electrodeNames[i], electrodeList->getNumItems()+1);\n    }\n\n    if (electrodeList->getNumItems() > 0)\n    {\n        if (selected == 0)\n            selected = electrodeList->getNumItems();\n\n        electrodeList->setSelectedId(selected);\n        //        electrodeList->setText(electrodeList->getItemText(electrodeList->getNumItems()-1));\n        lastId = electrodeList->getNumItems();\n        electrodeList->setEditableText(true);\n\n        drawElectrodeButtons(selected-1);\n        ElectrodeWithStim* e = processor->getElectrode(selected - 1);\n\n        int advancerIndex = 0;\n        for (int k=0; k<advancerIDs.size(); k++)\n        {\n            if (advancerIDs[k] == e->advancerID)\n            {\n                advancerIndex = 1+k;\n                break;\n            }\n        }\n\n        advancerList->setSelectedId(advancerIndex);\n        depthOffsetEdit->setText(String(e->depthOffsetMM,4),dontSendNotification);\n\n        if (processor->getAutoDacAssignmentStatus())\n        {\n            processor->assignDACtoChannel(0, e->channels[0]);\n            processor->assignDACtoChannel(1, e->channels[0]);\n        }\n     /*   Array<int> dacAssignmentToChannels = processor->getDACassignments();\n        // search for channel[0]. If found, set the combo box accordingly...\n        dacCombo->setSelectedId(1, sendNotification);\n        for (int i=0; i<dacAssignmentToChannels.size(); i++)\n        {\n            if (dacAssignmentToChannels[i] == e->channels[0])\n            {\n                dacCombo->setSelectedId(i+2, sendNotification);\n                processor->updateDACthreshold(i+2, e->thresholds[0]);\n                break;\n            }\n        }*/\n\n\n\n\n    }\n    if (spikeSorterCanvas != nullptr)\n        spikeSorterCanvas->update();\n}\n\n\nvoid SpikeSorterEditorWithStim::removeElectrode(int index)\n{\n    std::cout << \"Deleting electrode number \" << index << std::endl;\n    SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n    processor->removeElectrode(index);\n    refreshElectrodeList();\n\n    int newIndex = jmin(index, electrodeList->getNumItems()-1);\n    newIndex = jmax(newIndex, 0);\n\n    electrodeList->setSelectedId(newIndex, sendNotification);\n    electrodeList->setText(electrodeList->getItemText(newIndex));\n\n    if (electrodeList->getNumItems() == 0)\n    {\n        electrodeButtons.clear();\n        electrodeList->setEditableText(false);\n    }\n}\n\nvoid SpikeSorterEditorWithStim::labelTextChanged(Label* label)\n{\n    if (label == depthOffsetEdit)\n    {\n        // update electrode depth offset.\n        //Value v = depthOffsetEdit->getTextValue();\n        //double offset = v.getValue();\n\n        //int electrodeIndex = electrodeList->getSelectedId()-1;\n        //SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n        //if (electrodeIndex >= 0)\n        //\tprocessor->setElectrodeAdvancerOffset(electrodeIndex, offset);\n\n        if (spikeSorterCanvas != nullptr)\n            spikeSorterCanvas->update();\n\n    }\n}\n\nvoid SpikeSorterEditorWithStim::setElectrodeComboBox(int direction)\n{\n    int N = electrodeList->getNumItems();\n    int C = electrodeList->getSelectedId();\n    C+=direction;\n    if (C <= 0)\n        C = N;\n    if (C > N)\n        C = 1;\n    electrodeList->setSelectedId(C, sendNotification);\n}\n\nvoid SpikeSorterEditorWithStim::comboBoxChanged(ComboBox* comboBox)\n{\n    SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n\n   /* if (comboBox == dacCombo)\n    {\n        int selection = dacCombo->getSelectedId();\n        // modify the dac channel assignment...\n        if (selection > 1)\n        {\n            int selectedSubChannel = -1;\n            for (int i = 0; i < electrodeButtons.size(); i++)\n            {\n                if (electrodeButtons[i]->getToggleState())\n                {\n                    selectedSubChannel = i;\n                    break;\n                }\n            }\n            ElectrodeWithStim* e = processor->getActiveElectrode();\n            if (e != nullptr)\n            {\n                int dacchannel = selection-2;\n                processor->assignDACtoChannel(dacchannel, e->channels[selectedSubChannel]);\n            }\n        }\n\n    }\n    else*/ if (comboBox == electrodeList)\n    {\n        int ID = comboBox->getSelectedId();\n\n        if (ID == 0)\n        {\n            // modify electrode name\n            processor->setElectrodeName(lastId, comboBox->getText());\n            refreshElectrodeList();\n\n        }\n        else\n        {\n            // switch to a new electrode.\n            SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n            lastId = ID;\n            ElectrodeWithStim* e= processor->setCurrentElectrodeIndex(ID-1);\n            drawElectrodeButtons(ID-1);\n            int advancerIndex = 0;\n\n            audioMonitorButton->setToggleState(e->isMonitored, dontSendNotification);\n\n            for (int k=0; k<advancerIDs.size(); k++)\n            {\n                if (advancerIDs[k] == e->advancerID)\n                {\n                    advancerIndex = 1+k;\n                    break;\n                }\n            }\n            advancerList->setSelectedId(advancerIndex, dontSendNotification);\n            depthOffsetEdit->setText(String(e->depthOffsetMM,4),dontSendNotification);\n\n            if (processor->getAutoDacAssignmentStatus())\n            {\n                processor->assignDACtoChannel(0, e->channels[0]);\n                processor->assignDACtoChannel(1, e->channels[0]);\n            }\n         /*   Array<int> dacAssignmentToChannels = processor->getDACassignments();\n            // search for channel[0]. If found, set the combo box accordingly...\n            dacCombo->setSelectedId(1, sendNotification);\n            for (int i=0; i<dacAssignmentToChannels.size(); i++)\n            {\n                if (dacAssignmentToChannels[i] == e->channels[0])\n                {\n                    dacCombo->setSelectedId(i+2, sendNotification);\n                    break;\n                }\n            }*/\n\n        }\n\n\n\n    }\n    else if (comboBox == advancerList)\n    {\n        // attach advancer to electrode.\n        // int electrodeIndex = electrodeList->getSelectedId()-1;\n        // SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n        // int selectedAdvancer = advancerList->getSelectedId() ;\n        // if (electrodeIndex >= 0 && selectedAdvancer > 0)\n        // \tprocessor->setElectrodeAdvancer(electrodeIndex,advancerIDs[advancerList->getSelectedId()-1]);\n        // else\n        // \tadvancerList->setSelectedId(0,dontSendNotification);\n    }\n    else if (comboBox == sleepStateList)\n    {\n        ((SpikeSorterWithStim*) getProcessor())->setSleepState((SleepState) sleepStateList->getSelectedId());\n    }\n\n}\n\nvoid SpikeSorterEditorWithStim::checkSettings()\n{\n    electrodeList->setSelectedItemIndex(0);\n}\n\nvoid SpikeSorterEditorWithStim::drawElectrodeButtons(int ID)\n{\n\n    SpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n\n    electrodeButtons.clear();\n\n    int width = 20;\n    int height = 15;\n\n    int numChannels = processor->getNumChannels(ID);\n    int row = 0;\n    int column = 0;\n\n    Array<int> activeChannels;\n    Array<double> thresholds;\n\n    for (int i = 0; i < numChannels; i++)\n    {\n        ElectrodeButton* button = new ElectrodeButton(processor->getChannel(ID,i)+1);\n        electrodeButtons.add(button);\n\n        if (i == 0)\n        {\n            activeChannels.add(processor->getChannel(ID,i));\n            thresholds.add(processor->getChannelThreshold(ID,i));\n        }\n\n        button->setToggleState(i == 0, dontSendNotification);\n        button->setBounds(155+(column++)*width, 60+row*height, width, 15);\n        addAndMakeVisible(button);\n        button->addListener(this);\n\n        if (column % 2 == 0)\n        {\n            column = 0;\n            row++;\n        }\n\n    }\n\n    channelSelector->setActiveChannels(activeChannels);\n\n    thresholdSlider->setValues(thresholds);\n    thresholdSlider->setActive(true);\n    thresholdSlider->setEnabled(true);\n    thresholdSlider->setValue(processor->getChannelThreshold(ID,0),dontSendNotification);\n    repaint();\n    if (spikeSorterCanvas != nullptr)\n        spikeSorterCanvas->update();\n}\n\n\n// void SpikeSorterEditorWithStim::updateAdvancerList()\n// {\n\n// \tProcessorGraph *g = getProcessor()->getProcessorGraph();\n// \tArray<GenericProcessor*> p = g->getListOfProcessors();\n// \tfor (int k=0;k<p.size();k++)\n// \t{\n// \t\tif (p[k]->getName() == \"Advancers\")\n// \t\t{\n// \t\t\tAdvancerNode *node = (AdvancerNode *)p[k];\n// \t\t\tif (node != nullptr)\n// \t\t\t{\n// \t\t\t\tadvancerNames = node->getAdvancerNames();\n// \t\t\t\tadvancerIDs =  node->getAdvancerIDs();\n\n// \t\t\t\tadvancerList->clear(dontSendNotification);\n// \t\t\t\tfor (int i=0;i<advancerNames.size();i++)\n// \t\t\t\t{\n// \t\t\t\t\tadvancerList->addItem(advancerNames[i],1+i);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t}\n\n\n//         int selectedElectrode = electrodeList->getSelectedId();\n// \t\tif (selectedElectrode > 0) {\n// \t\t\tSpikeSorterWithStim* processor = (SpikeSorterWithStim*) getProcessor();\n// \t\t\tElectrodeWithStim *e = processor->getElectrode( selectedElectrode-1);\n// \t\t\tint advancerIndex = 0;\n// \t\t\tfor (int k=0;k<advancerIDs.size();k++)\n// \t\t\t{\n// \t\t\t\tif (advancerIDs[k] == e->advancerID)\n// \t\t\t\t{\n// \t\t\t\t\t\tadvancerIndex = 1+k;\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\tadvancerList->setSelectedId(advancerIndex);\n// \t\t\t}\n// \trepaint();\n// }\n",
			"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSorterEditorWithStim.cpp",
			"file_size": 29888,
			"file_write_time": 132278899618866395,
			"settings":
			{
				"buffer_size": 29888,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/*\n------------------------------------------------------------------\n\nThis file is part of the Open Ephys GUI\nCopyright (C) 2013 Open Ephys\n\n------------------------------------------------------------------\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n#ifndef __SPIKESORTBOXESWITHSTIM_H\n#define __SPIKESORTBOXESWITHSTIM_H\n\n#include \"SpikeSorterEditorWithStim.h\"\n#include <algorithm>    // std::sort\n#include <list>\n#include <queue>\n#include <atomic>\n\nclass SorterSpikeContainerWithStim : public ReferenceCountedObject\n{\npublic:\n\t//This invalidates the original SpikeEventPtr, so be careful\n\tSorterSpikeContainerWithStim(const SpikeChannel* channel, SpikeEvent::SpikeBuffer& data, int64 timestamp);\n\tSorterSpikeContainerWithStim() = delete;\n\n\tconst float* getData() const;\n\tconst SpikeChannel* getChannel() const;\n\tint64 getTimestamp() const;\n\tuint8 color[3];\n\tfloat pcProj[2];\n\tuint16 sortedId;\nprivate:\n\tint64 timestamp;\n\tHeapBlock<float> data;\n\tconst SpikeChannel* chan;\n};\ntypedef ReferenceCountedObjectPtr<SorterSpikeContainerWithStim> SorterSpikeWithStimPtr;\ntypedef ReferenceCountedArray<SorterSpikeContainerWithStim, CriticalSection> SorterSpikeWithStimArray;\n\nclass PCAcomputingThreadWithStim;\nclass UniqueIDgeneratorWithStim;\nclass PointDWithStim\n{\npublic:\n\n    PointDWithStim();\n    PointDWithStim(float x, float y);\n    PointDWithStim(const PointDWithStim& P);\n    const PointDWithStim operator+(const PointDWithStim& c1) const;\n    PointDWithStim& operator+=(const PointDWithStim& rhs);\n    PointDWithStim& operator-=(const PointDWithStim& rhs);\n\n\n    const PointDWithStim operator-(const PointDWithStim& c1) const;\n    const PointDWithStim operator*(const PointDWithStim& c1) const;\n\n    float cross(PointDWithStim c) const;\n    float X,Y;\n};\n\n\nclass BoxWithStim\n{\npublic:\n    BoxWithStim();\n    BoxWithStim(int channel);\n    BoxWithStim(float X, float Y, float W, float H, int ch=0);\n    bool LineSegmentIntersection(PointDWithStim p11, PointDWithStim p12, PointDWithStim p21, PointDWithStim p22);\n    bool isWaveFormInside(SorterSpikeWithStimPtr so);\n    double x,y,w,h; // x&w and specified in microseconds. y&h in microvolts\n    int channel;\n};\n\n\n/************************/\nclass HistogramWithStim\n{\npublic:\n    HistogramWithStim();\n    HistogramWithStim(int N, double T0, double T1);\n    ~HistogramWithStim();\n\n    void setParameters(int N, double T0, double T1);\n    std::vector<int> getCounter();\n    void reset();\n    void update(double x);\n\n    int Max;\n    double t0, t1;\n    std::vector<double> Time;\n    int numBins;\n    std::vector<int> Counter;\n\n};\n\nclass RunningStatsWithStim\n{\npublic:\n    RunningStatsWithStim();\n    ~RunningStatsWithStim();\n    void resizeWaveform(int newlength);\n    void reset();\n    HistogramWithStim getHistogram();\n    std::vector<double> getMean(int index);\n    std::vector<double> getStandardDeviation(int index);\n    void update(SorterSpikeWithStimPtr so);\n    bool queryNewData();\n\n    double LastSpikeTime;\n    bool newData;\n    HistogramWithStim hist;\n    std::vector<std::vector<double> > WaveFormMean,WaveFormSk,WaveFormMk;\n    double numSamples;\n\n\n};\n\n// BoxWithStim unit defines a single unit (with multiple boxes)\n// Each boxWithStim can be on a different channel\nclass BoxUnitWithStim\n{\npublic:\n    BoxUnitWithStim();\n    BoxUnitWithStim(int ID, int localID);\n    BoxUnitWithStim(BoxWithStim B, int ID, int localID);\n    bool isWaveFormInsideAllBoxes(SorterSpikeWithStimPtr so);\n    bool isActivated();\n    void activateUnit();\n    void deactivateUnit();\n    double getNumSecondsActive();\n    void toggleActive();\n    void addBox(BoxWithStim b);\n    void addBox();\n    int getNumBoxes();\n    void modifyBox(int boxindex, BoxWithStim b);\n    bool deleteBox(int boxindex);\n    BoxWithStim getBox(int boxWithStim);\n    void setBox(int boxid, BoxWithStim B);\n    void setBoxPos(int boxid, PointDWithStim P);\n    void setBoxSize(int boxid, double W, double H);\n    void MoveBox(int boxid, int dx, int dy);\n    std::vector<BoxWithStim> getBoxes();\n    int getUnitID();\n    int getLocalID();\n\tvoid updateWaveform(SorterSpikeWithStimPtr so);\n    static void setDefaultColors(uint8_t col[3], int ID);\n    void resizeWaveform(int newlength);\npublic:\n    int UnitID;\n    int localID; // used internally, for colors and position.\n    std::vector<BoxWithStim> lstBoxes;\n    uint8_t ColorRGB[3];\n    RunningStatsWithStim WaveformStat;\n    bool Active;\n    juce::int64 Activated_TS_S;\n    Time timer;\n\n};\n\n/*\nclass PCAjobWithStim\n{\npublic:\nPCAjobWithStim();\n};*/\nclass PCAjobWithStim : public ReferenceCountedObject\n{\npublic:\n    PCAjobWithStim(SorterSpikeWithStimArray& _spikes, float* _pc1, float* _pc2,\n           std::atomic<float>&,  std::atomic<float>&,  std::atomic<float>&,  std::atomic<float>&, std::atomic<bool>& _reportDone);\n    ~PCAjobWithStim();\n    void computeCov();\n    void computeSVD();\n\n    float** cov;\n    SorterSpikeWithStimArray spikes;\n    float* pc1, *pc2;\n    std::atomic<float>& pc1min, &pc2min, &pc1max, &pc2max;\n    std::atomic<bool>& reportDone;\nprivate:\n    int svdcmp(float** a, int nRows, int nCols, float* w, float** v);\n    float pythag(float a, float b);\n    int dim;\n};\n\ntypedef ReferenceCountedObjectPtr<PCAjobWithStim> PCAJobWithStimPtr;\ntypedef ReferenceCountedArray<PCAjobWithStim, CriticalSection> PCAJobWithStimArray;\n\nclass cPolygonWithStim\n{\npublic:\n    cPolygonWithStim();\n    bool isPointInside(PointDWithStim p);\n    std::vector<PointDWithStim> pts;\n    PointDWithStim offset;\n};\n\n\n\nclass PCAcomputingThreadWithStim : juce::Thread\n{\npublic:\n    PCAcomputingThreadWithStim();\n    void run(); // computes PCA on waveforms\n    void addPCAjob(PCAJobWithStimPtr job);\n\nprivate:\n    PCAJobWithStimArray jobs;\n\tCriticalSection lock;\n};\n\nclass PCAUnitWithStim\n{\npublic:\n    PCAUnitWithStim();\n    PCAUnitWithStim(int ID, int localID);\n    PCAUnitWithStim(cPolygonWithStim B, int ID, int localID_);\n    ~PCAUnitWithStim();\n    int getUnitID();\n    int getLocalID();\n\tbool isWaveFormInsidePolygon(SorterSpikeWithStimPtr so);\n    bool isPointInsidePolygon(PointDWithStim p);\n    void resizeWaveform(int newlength);\n\tvoid updateWaveform(SorterSpikeWithStimPtr so);\npublic:\n    int UnitID;\n    int localID; // used internally, for colors and position.\n    cPolygonWithStim poly;\n    uint8_t ColorRGB[3];\n    RunningStatsWithStim WaveformStat;\n    bool Active;\n    juce::int64 Activated_TS_S;\n    Time timer;\n};\n\n// Sort spikes from a single electrode (which could have any number of channels)\n// using the boxWithStim method. Any electrode could have an arbitrary number of units specified.\n// Each unit is defined by a set of boxes, which can be placed on any of the given channels.\nclass SpikeSortBoxesWithStim\n{\npublic:\n    SpikeSortBoxesWithStim(UniqueIDgeneratorWithStim* uniqueIDgenerator_, PCAcomputingThreadWithStim* pth, int numch, double SamplingRate, int WaveFormLength);\n    ~SpikeSortBoxesWithStim();\n\n    void resizeWaveform(int numSamples);\n\n\n\tvoid projectOnPrincipalComponents(SorterSpikeWithStimPtr so);\n\tbool sortSpike(SorterSpikeWithStimPtr so, bool PCAfirst);\n    void RePCA();\n    void addPCAunit(PCAUnitWithStim unit);\n    int addBoxUnit(int channel);\n    int addBoxUnit(int channel, BoxWithStim B);\n\n    void getPCArange(float& p1min,float& p2min, float& p1max,  float& p2max);\n    void setPCArange(float p1min,float p2min, float p1max,  float p2max);\n    void resetJobStatus();\n    bool isPCAfinished();\n\n    bool removeUnit(int unitID);\n\n    void removeAllUnits();\n    bool addBoxToUnit(int channel, int unitID);\n    bool addBoxToUnit(int channel, int unitID, BoxWithStim B);\n    bool removeBoxFromUnit(int unitID, int boxIndex);\n    int getNumBoxes(int unitID);\n    std::vector<BoxWithStim> getUnitBoxes(int unitID);\n    std::vector<BoxUnitWithStim> getBoxUnits();\n    std::vector<PCAUnitWithStim> getPCAUnits();\n\n    void getUnitColor(int UnitID, uint8& R, uint8& G, uint8& B);\n    void updateBoxUnits(std::vector<BoxUnitWithStim> _units);\n    void updatePCAUnits(std::vector<PCAUnitWithStim> _units);\n    int generateUnitID();\n    int generateLocalID();\n    void generateNewIDs();\n    void setSelectedUnitAndBox(int unitID, int boxID);\n    void getSelectedUnitAndBox(int& unitID, int& boxid);\n    void saveCustomParametersToXml(XmlElement* electrodeNode);\n    void loadCustomParametersFromXml(XmlElement* electrodeNode);\nprivate:\n    //void  StartCriticalSection();\n    //void  EndCriticalSection();\n    UniqueIDgeneratorWithStim* uniqueIDgenerator;\n    int numChannels, waveformLength;\n    int selectedUnit, selectedBox;\n    CriticalSection mut;\n    std::vector<BoxUnitWithStim> boxUnits;\n    std::vector<PCAUnitWithStim> pcaUnits;\n    float* pc1, *pc2;\n    std::atomic<float> pc1min, pc2min, pc1max, pc2max;\n    SorterSpikeWithStimArray spikeBuffer;\n    int bufferSize,spikeBufferIndex;\n    PCAcomputingThreadWithStim* computingThread;\n    bool bPCAJobSubmitted,bPCAcomputed,bRePCA;\n    std::atomic<bool> bPCAjobFinished ;\n\n\n};\n\n//Those are legacy methods from the old spike system that are must likely not needed in the new one\nfloat spikeDataBinToMicrovolts(SorterSpikeWithStimPtr  s, int bin, int ch = 0);\nfloat spikeDataIndexToMicrovolts(SorterSpikeWithStimPtr s, int index = 0);\nfloat spikeTimeBinToMicrosecond(SorterSpikeWithStimPtr s, int bin, int ch = 0);\nint microSecondsToSpikeTimeBin(SorterSpikeWithStimPtr s, float t, int ch = 0);\n\n\n#endif // __SPIKESORTBOXESWITHSTIM_H\n",
			"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSortBoxesWithStim.h",
			"file_size": 9972,
			"file_write_time": 132277941511824576,
			"settings":
			{
				"buffer_size": 9972,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/*\n    ------------------------------------------------------------------\n\n    This file is part of the Open Ephys GUI\n    Copyright (C) 2013 Open Ephys\n\n    ------------------------------------------------------------------\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n#ifndef __SPIKESORTERWITHSTIM_H_3F920F95__\n#define __SPIKESORTERWITHSTIM_H_3F920F95__\n\n#include <ProcessorHeaders.h>\n#include \"SpikeSorterEditorWithStim.h\"\n#include \"SpikeSortBoxesWithStim.h\"\n#include <algorithm>    // std::sort\n#include <queue>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\nenum SleepState : short;\nclass SpikeSorterEditorWithStim;\nclass SpikeHistogramPlotWithStim;\nclass Trial;\n/**\n\n  Detects spikes in a continuous signal and outputs events containing the spike data.\n\n  Allows the user to draw boundaries around clusters.\n\n  @see GenericProcessor, SpikeSorterEditorWithStim\n\n*/\n\n/*\nclass Histogram {\npublic:\n\tHistogram(float _minValue, float _maxValue, float _resolution, bool _throwOutsideSamples);\n\t//Histogram(float _minValue, float _maxValue, int _numBins, bool _throwOutsideSamples);\n\tvoid addSamples(float *Samples, int numSamples);\n\t~Histogram();\n\tvoid clear();\n\n\tfloat minValue, maxValue, resolution;\n\tint numBins;\n\tbool throwOutsideSamples;\n\tunsigned long *binCounts;\n\tfloat *binCenters;\n};\n*/\n\nclass PCAjobWithStim;\nclass PCAcomputingThreadWithStim;\nclass UniqueIDgeneratorWithStim\n{\npublic:\n    UniqueIDgeneratorWithStim()\n    {\n        globalUniqueID=0;\n    }\n    int generateUniqueID()\n    {\n        return ++globalUniqueID;\n    };\n    void setUniqueID(int ID)\n    {\n        globalUniqueID= ID;\n    }\n    int getLastUniqueID()\n    {\n        return globalUniqueID;\n    }\nprivate:\n    int globalUniqueID;\n};\n\n/* snatched from http://www.johndcook.com/blog/standard_deviation/ */\nclass RunningStatWithStim\n{\npublic:\n    RunningStatWithStim() : m_n(0) {}\n\n    void Clear()\n    {\n        m_n = 0;\n    }\n\n    void Push(double x)\n    {\n        m_n++;\n\n        // See Knuth TAOCP vol 2, 3rd edition, page 232\n        if (m_n == 1)\n        {\n            m_oldM = m_newM = x;\n            m_oldS = 0.0;\n        }\n        else\n        {\n            m_newM = m_oldM + (x - m_oldM) / m_n;\n            m_newS = m_oldS + (x - m_oldM)*(x - m_newM);\n\n            // set up for next iteration\n            m_oldM = m_newM;\n            m_oldS = m_newS;\n        }\n    }\n\n    int NumDataValues() const\n    {\n        return m_n;\n    }\n\n    double Mean() const\n    {\n        return (m_n > 0) ? m_newM : 0.0;\n    }\n\n    double Variance() const\n    {\n        return ((m_n > 1) ? m_newS / (m_n - 1) : 0.0);\n    }\n\n    double StandardDeviation() const\n    {\n        return sqrt(Variance());\n    }\n\nprivate:\n    int m_n;\n    double m_oldM, m_newM, m_oldS, m_newS;\n};\n\nclass ElectrodeWithStim\n{\npublic:\n    ElectrodeWithStim(int electrodeID, UniqueIDgeneratorWithStim* uniqueIDgenerator_, PCAcomputingThreadWithStim* pth,String _name, int _numChannels, int* _channels, float default_threshold, int pre, int post, float samplingRate , int sourceNodeId, int sourceSubIdx);\n    ~ElectrodeWithStim();\n\n    void resizeWaveform(int numPre, int numPost);\n\n    String name;\n\n    int numChannels;\n    int prePeakSamples, postPeakSamples;\n    int lastBufferIndex;\n\n    int advancerID;\n    float depthOffsetMM;\n\n    int electrodeID;\n    int sourceNodeId_;\n\tint sourceSubIdx;\n    int* channels;\n    double* thresholds;\n    bool* isActive;\n    double* voltageScale;\n    //float PCArange[4];\n\n    RunningStatWithStim* runningStats;\n    SpikeHistogramPlotWithStim* spikePlot;\n    \n    PCAcomputingThreadWithStim* computingThread;\n    UniqueIDgeneratorWithStim* uniqueIDgenerator;\n\n\tScopedPointer<SpikeSortBoxesWithStim> spikeSort;\n    bool isMonitored;\n\n    bool isExcluded;\n    long int internalClock;\n    bool atLeastOneRealSpike = false;\n    bool windowComplete = false;\n    bool spikeInWindow = false;\n};\n\nclass ContinuousCircularBufferWithStim\n{\npublic:\n    ContinuousCircularBufferWithStim(int NumCh, float SamplingRate, int SubSampling, float NumSecInBuffer);\n    void reallocate(int N);\n    void update(std::vector<std::vector<bool>> contdata, int64 hardware_ts, int64 software_ts, int numpts);\n    void update(AudioSampleBuffer& buffer, int64 hardware_ts, int64 software_ts, int numpts);\n    void update(int channel, int64 hardware_ts, int64 software_ts, bool rise);\n    int GetPtr();\n    void addTrialStartToSmartBuffer(int trialID);\n    int numCh;\n    int subSampling;\n    float samplingRate;\n    CriticalSection mut;\n    int numSamplesInBuf;\n    double numTicksPerSecond;\n    int ptr;\n    int bufLen;\n    int leftover_k;\n    double buffer_dx;\n\n    std::vector<std::vector<float> > Buf;\n    std::vector<bool> valid;\n    std::vector<int64> hardwareTS,softwareTS;\n};\n\n\n//class StringTS;\n\n\n\nclass SpikeSorterWithStim : public GenericProcessor\n{\npublic:\n\n    // CONSTRUCTOR AND DESTRUCTOR //\n\n    /** constructor */\n    SpikeSorterWithStim();\n\n    /** destructor */\n    ~SpikeSorterWithStim();\n\n\n    // PROCESSOR METHODS //\n\n    /** Processes an incoming continuous buffer and places new\n        spikes into the event buffer. */\n    void process(AudioSampleBuffer& buffer) override;\n    void handleEvent(const EventChannel* eventInfo, const MidiMessage& event, int sampleNum) override;\n    void setSleepState(const SleepState newSleepState);\n\n    /** Used to alter parameters of data acquisition. */\n    void setParameter(int parameterIndex, float newValue) override;\n\n    /** Called whenever the signal chain is altered. */\n    void updateSettings() override;\n    void createEventChannels() override;\n\n    /** Called prior to start of acquisition. */\n    bool enable() override;\n\n    /** Called after acquisition is finished. */\n    bool disable() override;\n\n    /** Called from setRecording whenever recording has started. */\n    void startRecording() override;\n\n    /** Called from setRecording whenever recording has stopped. */\n    void stopRecording() override;\n\n\n    bool isReady() override;\n    /** Creates the SpikeSorterEditorWithStim. */\n    AudioProcessorEditor* createEditor() override;\n\n    float getSelectedElectrodeNoise();\n    void clearRunningStatForSelectedElectrode();\n\n    //void addNetworkEventToQueue(StringTS S);\n\n    void postEventsInQueue(MidiBuffer& events);\n\n    // INTERNAL BUFFERS //\n\n    /** Extra samples are placed in this buffer to allow seamless\n        transitions between callbacks. */\n    AudioSampleBuffer overflowBuffer;\n\n\n    // CREATE AND DELETE ELECTRODES //\n\n    /** Adds an electrode with n channels to be processed. */\n    bool addElectrode(int nChans, String name, double depth);\n\n    void addProbes(String probeType,int numProbes, int nElectrodesPerProbe, int nChansPerElectrode,  double firstContactOffset, double interelectrodeDistance);\n\n    /** Removes an electrode with a given index. */\n    bool removeElectrode(int index);\n\n\n    // EDIT AND QUERY ELECTRODE SETTINGS //\n\n    /** Returns the number of channels for a given electrode. */\n    int getNumChannels(int index);\n\n    /** Edits the mapping between input channels and electrode channels. */\n    void setChannel(int electrodeIndex, int channelNum, int newChannel);\n\n    /** Returns the continuous channel that maps to a given\n    \telectrode channel. */\n    int getChannel(int index, int chan);\n\n    /** Sets the name of a given electrode. */\n    void setElectrodeName(int index, String newName);\n\n    /** */\n    void setChannelActive(int electrodeIndex, int channelNum, bool active);\n\n    /** */\n    bool isChannelActive(int electrodeIndex, int channelNum);\n\n    /** returns the current active electrode, i.e., the one displayed in the editor */\n    ElectrodeWithStim* getActiveElectrode();\n\n    /** Returns a StringArray containing the names of all electrodes */\n    StringArray getElectrodeNames();\n\n    /** modify a channel spike detection threshold */\n    void setChannelThreshold(int electrodeNum, int channelNum, float threshold);\n\n    /** returns a channel's detection threshold */\n    double getChannelThreshold(int electrodeNum, int channelNum);\n\n    /** used to generate messages over the network and to inform PSTH sink */\n    void addNewUnit(int electrodeID, int newUnitID, uint8 r, uint8 g, uint8 b);\n    void removeUnit(int electrodeID, int newUnitID);\n\n    /** saves all electrodes, thresholds, units, etc to xml */\n    void saveCustomParametersToXml(XmlElement* parentElement);\n    void loadCustomParametersFromXml();\n\n    /** returns the depth of an electrode. The depth is calculated as the\n    known depth of the advancer that is used to control that electrode, plus\n    the defined depth offset. Depth offset is mainly useful for depth probes,\n    in which the contact position is not always the at the tip */\n    //double getElectrodeDepth(int electrodeID);\n\n    /** returns the number of electrodes */\n    int getNumElectrodes();\n\n    /** clears up the spike plots. Called during updates */\n    void removeSpikePlots();\n\n    int getNumberOfChannelsForElectrode(int i);\n    String getNameForElectrode(int i);\n    void addSpikePlotForElectrode(SpikeHistogramPlotWithStim* sp, int i);\n    int getCurrentElectrodeIndex();\n    ElectrodeWithStim* setCurrentElectrodeIndex(int i);\n    ElectrodeWithStim* getElectrode(int i);\n    //StringTS createStringTS(String S);\n    //int64 getExtrapolatedHardwareTimestamp(int64 softwareTS);\n    //void postTimestamppedStringToMidiBuffer(StringTS s, MidiBuffer& events);\n    //void setElectrodeAdvancer(int i,int ID);\n    //void setElectrodeAdvancerOffset(int i, double v);\n    //double getAdvancerPosition(int advancerID);\n    //double getSelectedElectrodeDepth();\n    bool getAutoDacAssignmentStatus();\n    void seteAutoDacAssignment(bool status);\n    int getNumPreSamples();\n    int getNumPostSamples();\n    void setNumPreSamples(int numSamples);\n    void setNumPostSamples(int numSamples);\n    int getDACassignment(int channel);\n    void assignDACtoChannel(int dacOutput, int channel);\n    Array<int> getDACassignments();\n    void updateDACthreshold(int dacChannel, float threshold);\n    bool getThresholdSyncStatus();\n    void setThresholdSyncStatus(bool status);\n    bool getFlipSignalState();\n    void setFlipSignalState(bool state);\n    //void startRecording();\n    std::vector<float> getElectrodeVoltageScales(int electrodeID);\n    //void getElectrodePCArange(int electrodeID, float &minX,float &maxX,float &minY,float &maxY);\n    //void setElectrodePCArange(int electrodeID, float minX,float maxX,float minY,float maxY);\n\n    void removeAllUnits(int electrodeID);\n\n    void setElectrodeVoltageScale(int electrodeID, int index, float newvalue);\n    std::vector<int> getElectrodeChannels(int ID);\n\n    const OwnedArray<ElectrodeWithStim>& getElectrodes();\n\n    std::vector<String> electrodeTypes;\n    \n    void setEditAllState(bool val);\n    bool getEditAllState();\n    \n#if 0\n    /** sync PSTH : inform of a new electrode added  */\n    void updateSinks(ElectrodeWithStim* newElectrode);\n    /** sync PSTH : inform of an electrode removal */\n    void updateSinks(int electrodeID);\n    /** sync PSTH : inform of a channel swap */\n    void updateSinks(int electrodeID, int channelindex, int newchannel);\n    /** sync PSTH: inform of a new unit added / removed */\n    void updateSinks(int electrodeID, int unitID, uint8 r, uint8 g, uint8 b, bool addRemove);\n    /** sync PSTH: inform of a name change*/\n    void updateSinks(int electrodeID, String NewName);\n    /** sync PSTH: remove all units*/\n    void updateSinks(int electrodeID, bool b);\n#endif\n\nprivate:\n    UniqueIDgeneratorWithStim uniqueIDgenerator;\n    long uniqueSpikeID;\n    SorterSpikeWithStimPtr prevSpike;\n\n    void addElectrode(ElectrodeWithStim* newElectrode);\n    void increaseUniqueProbeID(String type);\n    int getUniqueProbeID(String type);\n\n    float ticksPerSec;\n    int uniqueID;\n    //std::queue<StringTS> eventQueue;\n    /** pointer to a continuous buffer. */\n    AudioSampleBuffer* dataBuffer;\n\n    float getDefaultThreshold();\n\n    int overflowBufferSize;\n\n    int sampleIndex;\n\n    std::vector<int> electrodeCounter;\n    float getNextSample(int& chan);\n    float getCurrentSample(int& chan);\n    bool samplesAvailable(int nSamples);\n\n    Array<bool> useOverflowBuffer;\n\n    int currentElectrode;\n    int currentChannelIndex;\n    int currentIndex;\n\n\n    int numPreSamples,numPostSamples;\n\n\n    bool PCAbeforeBoxes;\n    ContinuousCircularBufferWithStim* channelBuffers; // used to compute auto threshold\n\n    void resetElectrode(ElectrodeWithStim*);\n    CriticalSection mut;\n    bool autoDACassignment;\n    bool syncThresholds;\n //   RHD2000Thread* getRhythmAccess();\n    bool flipSignal;\n\n\tbool sorterReady{ false };\n\n    Time timer;\n\n    void addWaveformToSpikeObject(SpikeEvent::SpikeBuffer& s,\n                                  int& peakIndex,\n                                  int& electrodeNumber,\n                                  int& currentChannel);\n\n\n    OwnedArray<ElectrodeWithStim> electrodes;\n    PCAcomputingThreadWithStim computingThread;\n\n    void sendTtlEvent(int timestamp);\n    bool checkSleepState();\n    SleepState sleepStateSelection, currentSleepState;\n    EventChannel* ttlChannel;\n    int currentSleepStateLength = 0;\n    int ttlMessageUp = 1;\n    int ttlMessageDown = 0;\n    float sampleRate;\n    bool enableStim;\n\n    bool editAll = false;\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SpikeSorterWithStim);\n\n};\n\n\n\n\n/*\n\nclass circularBuffer {\npublic:\n\tcircularBuffer(int NumCh, int NumSamplesToHoldPerChannel, double SamplingRate);\n\t~circularBuffer();\n\n\tstd::vector<double> getDataArray(int channel, int N);\n\tdouble findThresholdForChannel(int channel);\n\tvoid update(AudioSampleBuffer& buffer);\n\nprivate:\n     CriticalSection mut;\n\n\tint numCh;\n\tint numSamplesInBuf;\n\tint ptr;\n\tdouble samplingRate;\n\tint bufLen;\n\tstd::vector<std::vector<double>> Buf;\n\tstd::vector<double> BufTS_H;\n\tstd::vector<double> BufTS_S;\n};\n\n\n*/\n\n\n\n\n\n\n\n\n\n\n\n#endif  // __SPIKESORTERWITHSTIM_H_3F920F95__\n",
			"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSorterWithStim.h",
			"file_size": 14542,
			"file_write_time": 132278902532211703,
			"settings":
			{
				"buffer_size": 14542,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/*\n    ------------------------------------------------------------------\n\n    This file is part of the Open Ephys GUI\n    Copyright (C) 2013 Open Ephys\n\n    ------------------------------------------------------------------\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n#ifndef __SPIKESORTEREDITORWITHSTIM_H_F0BD2DD9__\n#define __SPIKESORTEREDITORWITHSTIM_H_F0BD2DD9__\n\n#include <VisualizerEditorHeaders.h>\n\nclass SpikeSorterCanvasWithStim;\n\n/**\n\n  User interface for the SpikeSorter processor.\n\n  Allows the user to add single electrodes, stereotrodes, or tetrodes.\n\n  Parameters of individual channels, such as channel mapping, threshold,\n  and enabled state, can be edited.\n\n  @see SpikeSorter\n\n*/\n\nclass SpikeSorterEditorWithStim : public VisualizerEditor,\n    public Label::Listener,\n    public ComboBox::Listener\n\n{\npublic:\n    SpikeSorterEditorWithStim(GenericProcessor* parentNode, bool useDefaultParameterEditors);\n    virtual ~SpikeSorterEditorWithStim();\n    void buttonEvent(Button* button);\n    void labelTextChanged(Label* label);\n    void comboBoxChanged(ComboBox* comboBox);\n    void sliderEvent(Slider* slider);\n\n    void channelChanged (int chan, bool newState) override;\n\n    Visualizer* createNewCanvas();\n    void checkSettings();\n    void setThresholdValue(int chan, double threshold);\n    OwnedArray<ElectrodeButton> electrodeButtons;\n    SpikeSorterCanvasWithStim* spikeSorterCanvas;\n    //void updateAdvancerList();\n    void refreshElectrodeList(int selected = 0);\n    void setSelectedElectrode(int i);\n    int getSelectedElectrode();\n    void setElectrodeComboBox(int direction);\n\nprivate:\n    void drawElectrodeButtons(int);\n   \n\n\n\n    //  ComboBox* electrodeTypes;\n\tScopedPointer<ComboBox> electrodeList;// , dacCombo;\n    ScopedPointer<ComboBox> advancerList;\n    ScopedPointer<ComboBox> sleepStateList;\n    ScopedPointer<Label> advancerLabel, depthOffsetLabel, depthOffsetEdit;\n    ScopedPointer<Label> numElectrodes;\n\tScopedPointer<Label> thresholdLabel; // , dacAssignmentLabel;\n    ScopedPointer<TriangleButton> upButton;\n    ScopedPointer<TriangleButton> downButton;\n    ScopedPointer<UtilityButton> plusButton;\n    ScopedPointer<UtilityButton> configButton;\n    ScopedPointer<UtilityButton> removeElectrodeButton;\n    ScopedPointer<UtilityButton> audioMonitorButton;\n    ScopedPointer<ThresholdSlider> thresholdSlider;\n\n    Array<String> advancerNames ;\n    Array<int> advancerIDs;\n    void removeElectrode(int index);\n    void editElectrode(int index, int chan, int newChan);\n\n    int lastId;\n    bool isPlural;\n\n    Font font;\n\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SpikeSorterEditorWithStim);\n\n};\n\n\n\n\n#endif  // __SPIKESORTEREDITORWITHSTIM_H_F0BD2DD9__\n",
			"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSorterEditorWithStim.h",
			"file_size": 3314,
			"file_write_time": 132277941511824576,
			"settings":
			{
				"buffer_size": 3314,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"pack",
				"Install Package Control"
			]
		],
		"width": 461.0
	},
	"console":
	{
		"height": 171.0,
		"history":
		[
			"exit",
			"ls"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/mobshamilton/OpenEphys/plugin-GUI",
		"/home/mobshamilton/OpenEphys/plugin-GUI/Plugins",
		"/home/mobshamilton/OpenEphys/plugin-GUI/Plugins/OnlineDecoding"
	],
	"file_history":
	[
		"/home/mobshamilton/OpenEphys/plugin-GUI/Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSorterEditorWithStim.h",
		"/home/mobshamilton/OpenEphys/plugin-GUI/Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSorterCanvasWithStim.h",
		"/home/mobshamilton/OpenEphys/plugin-GUI/Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSorterCanvasWithStim.cpp",
		"/home/mobshamilton/OpenEphys/plugin-GUI/Plugins/OnlineDecoding/CMakeLists.txt",
		"/home/mobshamilton/OpenEphys/plugin-GUI/CMakeLists.txt",
		"/home/mobshamilton/OpenEphys/plugin-GUI/Plugins/OnlineDecoding/tensorflow/CMakeLists.txt",
		"/home/mobshamilton/OpenEphys/plugin-GUI/Plugins/OnlineDecoding/tensorflow/.gitignore",
		"/home/mobshamilton/OpenEphys/plugin-GUI/Plugins/PluginRules.cmake",
		"/home/mobshamilton/OpenEphys/plugin-GUI/open-ephys-GUI.sublime-project",
		"/home/mobshamilton/OpenEphys/plugin-GUI/Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSortBoxesWithStim.cpp",
		"/home/mobshamilton/OpenEphys/plugin-GUI/Build/open-ephys-GUI.sublime-project",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/OnlinePlaceDecoding/MOBSencoder",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/Thibault/tensorflow.rnn.print.py",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/OnlinePlaceDecoding/python/nnlearning_scriptRC.py",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/Thibault/tensorflow.rnn.gpu.py",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/Thibault/tensorflow.RCrnn.py",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/Thibault/tensorflow.rnn.py",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/OnlinePlaceDecoding/python/mobs_filtering.py",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/open-ephys-plugins/Stimulator/Source/StimulatorProcessor.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/open-ephys-plugins/Stimulator/Source/Stimulator.sublime-project",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/open-ephys-plugins/Stimulator/Source/CMakeLists.txt",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/globalconstants.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/main.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/spikeplot.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/spikeplot.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobsjsonpath.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/spikescopedialog.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/spikescopedialog.cpp",
		"/usr/include/c++/4.8/tuple",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobssleepscorer.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobssleepscorer.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobsjsonpath.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobsgroupselector.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobsgroupselector.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobsdecodingdisplay.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobsdecodingdisplay.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/spikegrouphandle.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobsneuralnets.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/MOBSinterface.sublime-project",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/MOBSinterface.sublime-workspace",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/RHD2000interface.pro",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/signalprocessor.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/spikegrouptrigger.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/setsaveformatdialog.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/triggerrecorddialog.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/helpdialogdacs.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/rhd2000evalboard.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/rhd2000evalboard.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/triggerrecorddialog.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/signalchannel.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobsneuralnets.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/spikegrouptrigger.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/spikegrouphandle.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/v0.1/mainwindow.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobsloading.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobsloading.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mainwindow.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/signalprocessor.h",
		"/usr/include/qt5/QtCore/qtypeinfo.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/build-RHD2000interface-Desktop-Debug/Makefile",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobspydecoder.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/mobspydecoder.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/signalgroup.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/signalgroup.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/signalsources.cpp",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/signalsources.h",
		"/home/mobshamilton/Dropbox/Kteam/intanMobsSource/source/jsoncpp.cpp",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/OnlinePlaceDecoding/python/mobs_networkbuilding.py",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/Thibault/highpassfilter.m",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/Thibault/nametest.m",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/Thibault/AddScriptName.m",
		"/home/mobshamilton/Documents/INTAN/intan_mod/build-RHD2000interface-Desktop-Release/mobspydecoder.py",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/OnlinePlaceDecoding/encoding.sh",
		"/home/mobshamilton/Downloads/hilbert/hiir/test/TestPhaseHalfPi.hpp",
		"/home/mobshamilton/Downloads/hilbert/hiir/test/TestAllClassesFnc.h",
		"/home/mobshamilton/Downloads/hilbert/hiir/test/main.cpp",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/Thibault/test_filters.py",
		"/home/mobshamilton/Downloads/DeltaFeedBack-master/Simulation/Simu_Online/SleepScoring_Simulation.m",
		"/home/mobshamilton/Downloads/DeltaFeedBack-master/README.md",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/jsoncpp.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/json.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mobsneuralnets.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mobsneuralnets.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mobspydecoder.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mobspydecoder.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mobsgroupselector.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mobsgroupselector.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/spikegrouptrigger.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/spikegrouphandle.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/spikegrouptrigger.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/spikegrouphandle.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/signalprocessor.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/main.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/spikescopedialog.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/spikescopedialog.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/signalprocessor.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/waveplot.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/waveplot.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/build-RHD2000interface-Desktop-Debug/mobspydecoder.py",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mobsjsonpath.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mobsjsonpath.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mobsloading.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mobsloading.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mainwindow.h",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/Thibault/INTANfilter.m",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/OnlinePlaceDecoding/matlab/filterDat.m",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/OnlinePlaceDecoding/matlab/export_spikes_frommat.m",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/rhd2000datablock.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/rhd2000datablock.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/rhd2000evalboard.cpp",
		"/media/DataMOBsRAIDN/ProjetERC2/Mouse-743/Hab/ERC-Mouse-743-01062018-Hab_SpikeRef.klg.8",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/rhd2000registers.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/spikeplot.h",
		"/home/mobshamilton/Documents/INTAN/INTANinterface/source/mainwindow.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/spikeplot.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/helpdialognotchfilter.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/helpdialognotchfilter.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/impedancefreqdialog.cpp",
		"/home/mobshamilton/Documents/INTAN/intan_mod/build-RHD2000interface-Desktop-Debug/people.json",
		"/home/mobshamilton/Dropbox/Kteam/ArduinoCodes/Sleep_StimLoop_PC_DB2018/Sleep_StimLoop_PC_DB2018.ino",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/signalchannel.h",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/signalchannel.cpp",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/OnlinePlaceDecoding/matlab/encoding.m",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/OnlinePlaceDecoding/python/mobs_nndecoding.py",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/OnlinePlaceDecoding/matlab/plot_position.m",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/OnlinePlaceDecoding/matlab/decoding.m",
		"/home/mobshamilton/Dropbox/Kteam/PrgMatlab/Thibault/compute_two_first_bins.m",
		"/home/mobshamilton/Documents/INTAN/intan_mod/source/mainwindow.cpp"
	],
	"find":
	{
		"height": 39.0
	},
	"find_in_files":
	{
		"height": 101.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"atLeastOneRealSpike",
			"ElectrodeWithStim",
			"addElectrode",
			"getUniqueProbeID",
			"addProbes",
			"enableStim",
			"addProbes",
			"addElectrode",
			"ElectrodeW",
			"Tetrode",
			"ElectrodeWithStim",
			"enum",
			"WINDOW_SIZE"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSortBoxesWithStim.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 61691,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSorterWithStim.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 60042,
						"regions":
						{
						},
						"selection":
						[
							[
								31302,
								31302
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 17982.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSorterEditorWithStim.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 29888,
						"regions":
						{
						},
						"selection":
						[
							[
								15645,
								15645
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6928.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		},
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 3,
					"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSortBoxesWithStim.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9972,
						"regions":
						{
						},
						"selection":
						[
							[
								973,
								973
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSorterWithStim.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14542,
						"regions":
						{
						},
						"selection":
						[
							[
								4357,
								4357
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2673.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "Plugins/OnlineDecoding/SpikeSorterWithStim/SpikeSorterEditorWithStim.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3314,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 38.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				0,
				1,
				1,
				2
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			0.915341682161,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 188.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "open-ephys-GUI - all",
	"project": "open-ephys-GUI.sublime-project",
	"replace":
	{
		"height": 48.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"MainWindow"
			]
		],
		"width": 392.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 316.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
